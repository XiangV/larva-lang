import __internal, debug;

//类型对象全局唯一，即可以用===和!==判是否为同一类型，为简单起见用比较朴素的方式做

!<<

import (
    "reflect"
    "sync"
)

var (
    lar_reflect_type_map_lock sync.RWMutex
    lar_reflect_type_map      = map[string]*lar_cls_@<<Type>>{}
)

//操作type_map，获取和设置类型，获取时若不存在则返回nil，设置时若存在则不覆盖，并返回map中最终的type结果，保证唯一性

func lar_go_func_@<<get_type_from_map>>(name string) *lar_cls_@<<Type>> {
    lar_reflect_type_map_lock.RLock()
    defer lar_reflect_type_map_lock.RUnlock()

    return lar_reflect_type_map[name]
}

func lar_go_func_@<<set_type_to_map>>(name string, tp *lar_cls_@<<Type>>) *lar_cls_@<<Type>> {
    lar_reflect_type_map_lock.Lock()
    defer lar_reflect_type_map_lock.Unlock()

    if old_tp := lar_reflect_type_map[name]; old_tp != nil {
        return old_tp
    }
    lar_reflect_type_map[name] = tp
    return tp
}

!>>

public class Type
{
    public String str()
    {
        return this.name();
    }

    public String repr()
    {
        return "<reflect.Type %s>".(this.name());
    }

    public String name()
    {
        return this._name;
    }

    public Value zero_value()
    {
        return value_of(this.zv);
    }

    public bool is_primitive()
    {
        !<<
        _, ok := this.m_zv.(lar_reflect_intf)
        return !ok
        !>>
    }

    void throw_on_primitive()
    {
        if (this.is_primitive())
        {
            throw(new Error{"‘%s’是基础类型".(this.name())});
        }
    }

    public bool can_new_empty()
    {
        !<<
        if lri, ok := this.m_zv.(lar_reflect_intf); ok {
            return lri.lar_reflect_can_new_empty()
        }
        !>>
        return false;
    }

    public Value new_empty()
    {
        this.throw_on_primitive();
        Any a;
        !<<
        l_a = this.m_zv.(lar_reflect_intf).lar_reflect_new_empty()
        !>>
        if (a === nil)
        {
            throw(new Error{"‘%s’不支持new_empty操作".(this.name())});
        }
        return value_of(a);
    }

    public AttrInfo[] attr_infos()
    {
        this.throw_on_primitive();
        return this._attr_infos.shallow_copy();
    }

    void init_attr_infos()
    {
        if (this.is_primitive())
        {
            return;
        }

        long count;
        !<<
        ais := this.m_zv.(lar_reflect_intf).lar_reflect_attr_infos()
        l_count = int64(len(ais))
        !>>
        this._attr_infos = new AttrInfo[count];
        for (long i = 0; i < count; ++ i)
        {
            !<<
            ai := ais[l_i];
            !>>

            long tag_count;
            !<<
            l_tag_count = int64(len(ai.tags))
            !>>
            var attr_info_tags = new Pair<String, String>[tag_count];
            for (long j = 0; j < tag_count; ++ j)
            {
                String tag_name, tag_value;
                !<<
                tag := ai.tags[l_j]
                l_tag_name = lar_str_from_go_str(tag.name)
                l_tag_value = lar_str_from_go_str(tag.value)
                !>>
                attr_info_tags[j] = make_pair(tag_name, tag_value);
            }

            AttrInfo attr_info;
            !<<
            l_attr_info = &lar_cls_@<<AttrInfo>>{
                m__cls:         this,
                m__type_name:   lar_str_from_go_str(ai.tn),
                m__zv:          ai.zv,
                m__name:        lar_str_from_go_str(ai.name),
                m__tags:        l_attr_info_tags,
            }
            !>>
            this._attr_infos[i] = attr_info;
        }
    }

/*
    public bool can_new_instance(Value[] args)
    {
        var args_raw = values_to_raw(args);
        !<<
        if lri, ok := this.m_zv.(lar_reflect_intf); ok {
            return lri.lar_reflect_can_new_instance(l_args_raw.arr)
        }
        !>>
        return false;
    }

    public Value new_instance(Value[] args)
    {
        var args_raw = values_to_raw(args);
        this.throw_on_primitive();
        Any a;
        !<<
        l_a = this.m_zv.(lar_reflect_intf).lar_reflect_new_instance(lar_fiber, l_args_raw.arr)
        !>>
        if (a === nil)
        {
            throw(new Error{"new_instance失败：类型‘%s’".(this.name())});
        }
        return value_of(a);
    }
*/

    String _name; //类型名
    Any    zv;    //此类型的zero_value

    AttrInfo[] _attr_infos;
}

//返回输入对象的类型，如果输入nil接口，则返回nil
public Type type_of(Any a)
{
    if (a === nil)
    {
        return nil;
    }
    String name = __internal.reflect_type_name(a);
    if (__internal.is_go_type_name(name))
    {
        throw(new NotLarvaObject{name});
    }
    Any zv;
    Type tp;
    !<<
    name := lar_str_to_go_str(l_name)
    l_tp = lar_go_func_@<<get_type_from_map>>(name)
    if l_tp != nil {
        return l_tp
    }
    l_zv = reflect.Zero(reflect.TypeOf(l_a)).Interface()
    !>>
    tp = new Type{
        _name: name,
        zv:    zv,
    };
    tp.init_attr_infos();
    !<<
    return lar_go_func_@<<set_type_to_map>>(name, l_tp)
    !>>
}
