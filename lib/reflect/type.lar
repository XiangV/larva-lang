import __internal, debug;

//类型对象全局唯一，即可以用===和!==判是否为同一类型，用一个map存放，程序启动时初始化

!<<

import (
    "reflect"
)

var lar_reflect_type_map = map[string]*lar_cls_@<<Type>>{}

func lar_go_func_@<<init_type_map>>() {
    //第一步：用Type对象填充map
    for _, zv := range lar_reflect_all_zvs {
        if zv == nil {
            panic("bug：lar_reflect_all_zvs有nil接口")
        }
        tn, is_go_type_name := lar_go_func_@<<__internal.reflect_type_name>>(zv);
        if is_go_type_name {
            panic("bug：lar_reflect_all_zvs有go的对象")
        }
        tn_go_str := lar_str_to_go_str(tn)
        if _, ok := lar_reflect_type_map[tn_go_str]; ok {
            panic("bug：lar_reflect_all_zvs存在重复类型的值")
        }
        if reflect.Zero(reflect.TypeOf(zv)).Interface() != zv {
            panic("bug：lar_reflect_all_zvs存在非零值")
        }

        tp := &lar_cls_@<<Type>>{
            m__name: tn,
            m_zv:    zv,
        }
        lar_reflect_type_map[tn_go_str] = tp
    }
    //第二步：初始化Type的其他信息，因为这个过程中可能会用到type_of，所以和上一步分开进行
    lar_fiber, cancel := lar_go_func_new_fiber_ctx_with_cancel(nil, "reflect.init_type_map")
    defer cancel()
    for _, tp := range lar_reflect_type_map {
        tp.lar_method_@<<init_attr_infos>>(lar_fiber)
    }
}

func init() {
    lar_go_func_@<<init_type_map>>()
}

!>>

public class Type
{
    public String str()
    {
        return this.name();
    }

    public String repr()
    {
        return "<reflect.Type %s>".(this.name());
    }

    public String name()
    {
        return this._name;
    }

    public Value zero_value()
    {
        return value_of(this.zv);
    }

    public bool is_primitive()
    {
        !<<
        _, ok := this.m_zv.(lar_reflect_intf)
        return !ok
        !>>
    }

    void throw_on_primitive()
    {
        if (this.is_primitive())
        {
            throw(new Error{"‘%s’是基础类型".(this.name())});
        }
    }

    public bool can_new_empty()
    {
        !<<
        if lri, ok := this.m_zv.(lar_reflect_intf); ok {
            return lri.lar_reflect_can_new_empty()
        }
        !>>
        return false;
    }

    public Value new_empty()
    {
        this.throw_on_primitive();
        Any a;
        !<<
        l_a = this.m_zv.(lar_reflect_intf).lar_reflect_new_empty()
        !>>
        if (a === nil)
        {
            throw(new Error{"‘%s’不支持new_empty操作".(this.name())});
        }
        return value_of(a);
    }

    public AttrInfo[] attr_infos()
    {
        this.throw_on_primitive();
        return this._attr_infos.shallow_copy();
    }

    void init_attr_infos()
    {
        if (this.is_primitive())
        {
            return;
        }

        long count;
        !<<
        ais := this.m_zv.(lar_reflect_intf).lar_reflect_attr_infos()
        l_count = int64(len(ais))
        !>>
        this._attr_infos = new AttrInfo[count];
        for (long i = 0; i < count; ++ i)
        {
            !<<
            ai := ais[l_i];
            !>>

            long tag_count;
            !<<
            l_tag_count = int64(len(ai.tags))
            !>>
            var attr_info_tags = new Pair<String, String>[tag_count];
            for (long j = 0; j < tag_count; ++ j)
            {
                String tag_name, tag_value;
                !<<
                tag := ai.tags[l_j]
                l_tag_name = lar_str_from_go_str(tag.name)
                l_tag_value = lar_str_from_go_str(tag.value)
                !>>
                attr_info_tags[j] = make_pair(tag_name, tag_value);
            }

            AttrInfo attr_info;
            !<<
            l_attr_info = &lar_cls_@<<AttrInfo>>{
                m__cls:         this,
                m__type_name:   lar_str_from_go_str(ai.tn),
                m__type:        lar_func_@<<type_of>>(lar_fiber, ai.zv),
                m__name:        lar_str_from_go_str(ai.name),
                m__tags:        l_attr_info_tags,
            }
            !>>
            this._attr_infos[i] = attr_info;
        }
    }

/*
    public bool can_new_instance(Value[] args)
    {
        var args_raw = values_to_raw(args);
        !<<
        if lri, ok := this.m_zv.(lar_reflect_intf); ok {
            return lri.lar_reflect_can_new_instance(l_args_raw.arr)
        }
        !>>
        return false;
    }

    public Value new_instance(Value[] args)
    {
        var args_raw = values_to_raw(args);
        this.throw_on_primitive();
        Any a;
        !<<
        l_a = this.m_zv.(lar_reflect_intf).lar_reflect_new_instance(lar_fiber, l_args_raw.arr)
        !>>
        if (a === nil)
        {
            throw(new Error{"new_instance失败：类型‘%s’".(this.name())});
        }
        return value_of(a);
    }
*/

    String _name; //类型名
    Any    zv;    //此类型的zero_value

    AttrInfo[] _attr_infos;
}

//获取larva对象的类型名，即__internal.reflect_type_name支持的那些，失败则抛出异常
String get_larva_type_name(Any a)
{
    String tn;
    bool is_go_type_name;
    !<<
    l_tn, l_is_go_type_name = lar_go_func_@<<__internal.reflect_type_name>>(l_a)
    !>>
    if (is_go_type_name)
    {
        throw(new NotLarvaObject{tn});
    }
    return tn;
}

//返回输入对象的类型，如果输入nil接口，则返回nil
public Type type_of(Any a)
{
    if (a === nil)
    {
        return nil;
    }

    //所有type都初始化好了，直接从map读，如果读不到就是编译器bug了
    var tn = get_larva_type_name(a);
    Type tp;
    !<<
    l_tp = lar_reflect_type_map[lar_str_to_go_str(l_tn)]
    !>>
    debug.assert(tp !== nil, "bug");
    return tp;
}
