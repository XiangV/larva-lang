import __internal, debug;

//类型对象全局唯一，即可以用===和!==判是否为同一类型，为简单起见用比较朴素的方式做

!<<

import (
    "reflect"
    "sync"
)

var (
    lar_reflect_type_map_lock sync.RWMutex
    lar_reflect_type_map      = map[string]*lar_cls_@<<Type>>{}
)

//操作type_map，获取和设置类型，获取时若不存在则返回nil，设置时若存在则不覆盖，并返回map中最终的type结果，保证唯一性

func lar_go_func_@<<get_type_from_map>>(name string) *lar_cls_@<<Type>> {
    lar_reflect_type_map_lock.RLock()
    defer lar_reflect_type_map_lock.RUnlock()

    return lar_reflect_type_map[name]
}

func lar_go_func_@<<set_type_to_map>>(name string, tp *lar_cls_@<<Type>>) *lar_cls_@<<Type>> {
    lar_reflect_type_map_lock.Lock()
    defer lar_reflect_type_map_lock.Unlock()

    if old_tp := lar_reflect_type_map[name]; old_tp != nil {
        return old_tp
    }
    lar_reflect_type_map[name] = tp
    return tp
}

!>>

public class Type
{
    public String str()
    {
        return this.name();
    }

    public String repr()
    {
        return "<reflect.Type %s>".(this.name());
    }

    public String name()
    {
        return this._name;
    }

    public Value zero_value()
    {
        return value_of(this.zv);
    }

    public bool is_primitive()
    {
        !<<
        _, ok := this.m_zv.(lar_reflect_intf)
        return !ok
        !>>
    }

    void throw_on_primitive()
    {
        if (this.is_primitive())
        {
            throw(new Error{"‘%s’是基础类型".(this.name())});
        }
    }

    public bool can_new_empty()
    {
        !<<
        if lri, ok := this.m_zv.(lar_reflect_intf); ok {
            return lri.lar_reflect_can_new_empty()
        }
        !>>
        return false;
    }

    public Value new_empty()
    {
        this.throw_on_primitive();
        Any a;
        !<<
        l_a = this.m_zv.(lar_reflect_intf).lar_reflect_new_empty()
        !>>
        if (a === nil)
        {
            throw(new Error{"‘%s’不支持new_empty操作".(this.name())});
        }
        return value_of(a);
    }

    public FieldInfo[] field_infos()
    {
        this.throw_on_primitive();
        long count;
        !<<
        fis := this.m_zv.(lar_reflect_intf).lar_reflect_field_infos()
        l_count = int64(len(fis))
        !>>
        var field_infos = new FieldInfo[count];
        for (long i = 0; i < count; ++ i)
        {
            FieldInfo field_info;
            !<<
            fi := fis[l_i];
            l_field_info = lar_new_obj_lar_cls_@<<FieldInfo>>(lar_fiber, this, fi.tn, fi.zv, fi.name, fi.tags)
            !>>
            field_infos[i] = field_info;
        }
        return field_infos;
    }

/*
    public bool can_new_instance(Value[] args)
    {
        var args_raw = values_to_raw(args);
        !<<
        if lri, ok := this.m_zv.(lar_reflect_intf); ok {
            return lri.lar_reflect_can_new_instance(l_args_raw.arr)
        }
        !>>
        return false;
    }

    public Value new_instance(Value[] args)
    {
        var args_raw = values_to_raw(args);
        this.throw_on_primitive();
        Any a;
        !<<
        l_a = this.m_zv.(lar_reflect_intf).lar_reflect_new_instance(lar_fiber, l_args_raw.arr)
        !>>
        if (a === nil)
        {
            throw(new Error{"new_instance失败：类型‘%s’".(this.name())});
        }
        return value_of(a);
    }
*/

    String _name; //类型名
    Any    zv;    //此类型的zero_value
}

//返回输入对象的类型，如果输入nil接口，则返回nil
public Type type_of(Any a)
{
    if (a === nil)
    {
        return nil;
    }
    String name = __internal.reflect_type_name(a);
    if (__internal.is_go_type_name(name))
    {
        throw(new NotLarvaObject{name});
    }
    Any zv;
    Type tp;
    !<<
    name := lar_str_to_go_str(l_name)
    l_tp = lar_go_func_@<<get_type_from_map>>(name)
    if l_tp != nil {
        return l_tp
    }
    l_zv = reflect.Zero(reflect.TypeOf(l_a)).Interface()
    !>>
    tp = new Type{
        _name: name,
        zv:    zv,
    };
    !<<
    return lar_go_func_@<<set_type_to_map>>(name, l_tp)
    !>>
}
