import __internal;

interface Ref
{
    String type_name();
    Any get();
    bool can_set(Any a);
    void set(Any a);
}

public class Value
{
    public String str()
    {
        if (this.is_ref())
        {
            return this.repr();
        }
        return "%s".(this.v);
    }

    public String repr()
    {
        Any a;
        String tp;
        if (this.is_ref())
        {
            a = this.r.get();
            tp = "ref ".concat(this.r.type_name());
        }
        else
        {
            a = this.v;
            tp = "%T".(a);
        }
        return "<Value of <%s> %r>".(tp, a);
    }

    //内部使用，不管是普通值还是ref指针都直接返回，用于lar_reflect_intf等更底层的接口
    GoAny get_raw()
    {
        return this.v;
    }

    public Any get()
    {
        return this.r.get() if this.is_ref() else (Any)this.v;
    }

    public String ref_type_name()
    {
        if (this.is_ref())
        {
            return this.r.type_name();
        }
        throw(new Error{"Value的值不是ref类型"});
    }

    public Type type()
    {
        return type_of(this.get());
    }

    public bool is_ref()
    {
        return this.r !== nil;
    }

    public bool can_set(Any a)
    {
        return this.is_ref() && this.r.can_set(a);
    }

    public void set(Any a)
    {
        this.r.set(a) if this.is_ref() else throw(new Error{"Value的值不是ref类型，不能set"});
    }

    Any get_instance()
    {
        Any a = this.get();
        bool ok;
        !<<
        _, l_ok = l_a.(lar_reflect_intf)
        !>>
        if (!ok)
        {
            throw(new Error{"‘%r’不是一个Larva的类实例".(this)});
        }
        return a;
    }

    //返回一个类实例的所有字段的ref值
    public Value[] fields()
    {
        Any a = this.get_instance();
        //todo
    }

    GoAny v; //具体的值，如果是ref，则为一个指针
    Ref   r; //当为ref时，对其操作的接口，普通值的这个字段为nil
}

public Value value_of(Any v)
{
    String tn = __internal.reflect_type_name(v);
    if (__internal.is_go_type_name(tn))
    {
        throw(new NotLarvaObject{tn});
    }
    return new Value{
        v: v,
    };
}

public Value value_of_ref<T>(ref T t)
{
    GoAny v;
    !<<
    l_v = l_t;
    !>>
    String name_of_T = type_name<T>();
    return new Value{
        v: v,
        r: []{
            String type_name()
            {
                return name_of_T;
            }

            Any get()
            {
                return t;
            }

            bool can_set(Any a)
            {
                return try_assert_type<T>(a, ref _);
            }

            void set(Any a)
            {
                T av;
                if (try_assert_type(a, ref av))
                {
                    t = av;
                    return;
                }
                throw(new Error{"无法将类型‘%T’的值赋值给类型‘%s’".(a, name_of_T)});
            }
        },
    };
}

GoAny[] values_to_raw(Value[] vs)
{
    long sz = vs.size();
    var rs = new GoAny[sz];
    for (long i = 0; i < sz; ++ i)
    {
        rs[i] = vs[i].get_raw();
    }
    return rs;
}
