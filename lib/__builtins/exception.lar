//可以用throw函数抛出的对象类型
public interface Throwable
{
    public String str();
}

//抛出异常
public void throw(Throwable t)
{
    !<<
    panic(lar_exc_create_catched_throwable(l_t, 2))
    !>>
}

//捕获语法返回的对象：抛出的对象+traceback的组合
//定义：Catched<Throwable>是所有Catched对象的base
public class Catched<T>
{
    Catched(T t, String tb)
    {
        this.t = t;
        this.tb = tb;
    }

    public void rethrow()
    {
        var c = new Catched<Throwable>(this.t, this.tb);
        !<<
        panic(l_c)
        !>>
    }

    public T throwed()
    {
        return this.t;
    }

    public String traceback()
    {
        return this.tb;
    }

    T t;
    String tb;
}

//--------------------------------------------------------------------

/*
下面的catch相关的代码较为特殊，编译器会在代码生成阶段做一些特殊修改
主要原因在于：go规定recover必须在defer func中直接执行，即直接defer recover()或在defer func中调用的函数里用recover都无法捕获panic
因此必须在larva调用下面两个catch函数的时候，同时调用recover并将结果传进来，但语法上让程序员无感知
编译器的大致处理步骤就是在代码生成部分对这两个catch增加参数（定义和调用都需要调整），在代码实现中用native_code处理额外增加的参数
*/

//将recover捕获的go的异常转为larva的Catched对象
Catched<Throwable> _go_recovered_to_catched(GoAny r)
{
    if (r === nil) {
        return nil;
    }
    Catched<Throwable> c;
    if (try_assert_type(r, ref c))
    {
        return c;
    }
    !<<
    //不是larva自己的异常，检查下是否需要转换
    l_c = lar_exc_convert_go_recovered_to_lar_throwed(l_r)
    if l_c == nil {
        //转换失败
        panic(l_r)
    }
    !>>
    return c;
}

//捕获Throwable对象
public Catched<Throwable> catch_throwable(/*GoAny _go_recovered*/)
{
    GoAny r;
    !<<
    l_r = _go_recovered
    !>>
    return _go_recovered_to_catched(r);
}

//捕获指定类型的异常
public Catched<T> catch<T>(/*GoAny _go_recovered*/)
{
    GoAny r;
    !<<
    l_r = _go_recovered
    !>>
    var c = _go_recovered_to_catched(r);
    if (c === nil)
    {
        //无异常
        return nil;
    }
    T throwed;
    if (try_assert_type(c.throwed(), ref throwed))
    {
        return new Catched<T>(throwed, c.traceback());
    }
    //不是当前需要的类型，继续往上抛
    c.rethrow();
}

//---------------------------------------------------------------------

//另一种捕获异常的编码形式，传入一个Callable接口的对象（一般是闭包），会调用它并将捕获的异常返回

void _call_and_catch<T>(Callable callee, ref Catched<T> c)
{
    defer
    {
        c = catch<T>();
    }
    callee.call();
}

public Catched<T> call_and_catch<T>(Callable callee)
{
    Catched<T> c;
    _call_and_catch(callee, ref c);
    return c;
}

public Catched<Throwable> nothrow_call(Callable callee)
{
    return call_and_catch<Throwable>(callee);
}

//---------------------------------------------------------------------

//空异常，用于一些简单的不含信息的异常的base，异常区分只需要通过名字来识别
public class EmptyException
{
    public String str()
    {
        return "";
    }
}

//这里是通用的一些内建异常类型

//运行时类型转换（从接口到类型或其他接口）失败的错误
public class TypeAssertionError
{
    EmptyException e usemethod;
}

//索引（下标）错误，用于数组、Slice、Vector等可用下标定位元素的相关代码中
public class IndexError
{
    public IndexError(long i)
    {
        this.has_idx = true;
        this.idx = i;
    }

    public String str()
    {
        if (this.has_idx)
        {
            return "%d".(this.idx);
        }
        else
        {
            return "<none>";
        }
    }

    bool has_idx;
    long idx;
}

//下标范围错误，用于slice、sub_str之类的取范围相关代码
public class RangeError
{
    public RangeError(long l, long b, long e)
    {
        this.has_range_info = true;
        this.len = l;
        this.begin = b;
        this.end = e;
    }

    public String str()
    {
        if (this.has_range_info)
        {
            return "[%d][%d:%d]".(this.len, this.begin, this.end);
        }
        else
        {
            return "<none>";
        }
    }

    bool has_range_info;
    long len;
    long begin;
    long end;
}

//通用的下标检查，检查不通过则抛出RangeError
public void check_range(long l, long b, long e)
{
    if (l < 0 || b < 0 || b > l || e < b || e > l)
    {
        throw(new RangeError(l, b, e));
    }
}

//键错误，用于各种映射、集合等用到Key的地方，k为错误的键的字符串描述
public class KeyError
{
    public KeyError(String k)
    {
        this.k = k;
    }

    String k usemethod(str);
}

//值错误，用于根据值解析、查找等操作的地方，v为错误的值的字符串描述
public class ValueError
{
    public ValueError(String v)
    {
        this.v = v;
    }

    String v usemethod(str);
}

//go的error类型的一个port，用于一些native代码从error到异常的转换
public class GoError
{
    public String str()
    {
        !<<
        return lar_str_from_go_str("[GoError]" + this.err.Error())
        !>>
    }

    public GoError go_err()
    {
        return this;
    }

    !<<
    err error
    !>>
}

public interface GoErrorPorter
{
    public GoError go_err();
}
