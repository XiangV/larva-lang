/*
GoAny和Any一样，都对应的go层面的interface{}，用不同名字只是为了在逻辑上区分不同场景的不同用法
显式用GoAny的代码表示对应类型可能为非larva类型
用Any的地方表示这里逻辑上只允许用larva类型
*/
public interface GoAny
{
}

public interface Any
{
}

public T zero_value<T>()
{
    T t;
    return t;
}

public T assert_type<T>(GoAny a)
{
    !<<
    return l_a.(@<<{T}>>)
    !>>
}

public bool try_assert_type<T>(GoAny a, ref T t)
{
    bool ok;
    !<<
    *l_t, l_ok = l_a.(@<<{T}>>)
    !>>
    return ok;
}

//因为经常会有将闭包回调作为参数传入的情况，弄个通用的接口在这里
public interface Callable
{
    public void call();
}

/*
模拟C等语言中的‘?:’表达式，但采用函数的方式
larva并没有直接支持‘?:’，主要是这个运算在和其他运算以及多个‘?:’使用的时候容易弄出一些混乱的代码，不推荐使用
但是这个东东时常能让代码更明确简化，所以还是提供一个替代品
需要注意的是，由于cond_expr是函数，所以a和b在传入的时候就已经求值了，而不像‘?:’那样根据cond判断结果再选择求值其中一个
*/
public T cond_expr<T>(bool cond, T a, T b)
{
    if (cond)
    {
        return a;
    }
    return b;
}
