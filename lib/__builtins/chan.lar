/*
Channel通讯类，用于fiber之间的通讯，实际就是go的chan的包装
若Chan关闭，recv会返回T的zero_value并通过ref参数指示是否被关闭，send则会crash
*/

public class Chan<T>
{
    public Chan(long buf_size)
    {
        if (buf_size < 0)
        {
            throw(new ValueError("无效的缓冲大小：%d".(buf_size)));
        }
        !<<
        this.ch = make(chan @<<{T}>>, l_buf_size)
        !>>
    }

    public long size()
    {
        !<<
        return int64(len(this.ch))
        !>>
    }

    public long buf_size()
    {
        !<<
        return int64(cap(this.ch))
        !>>
    }

    public void send(T data)
    {
        !<<
        this.ch <- l_data
        !>>
    }

    public bool try_send(T data)
    {
        !<<
        select {
        case this.ch <- l_data:
            return true
        default:
            return false
        }
        !>>
    }

    public void close()
    {
        !<<
        close(this.ch)
        !>>
    }

    public T recv(ref bool closed)
    {
        T t;
        bool ok;
        !<<
        l_t, l_ok = <-this.ch
        !>>
        closed = !ok;
        return t;
    }

    public T try_recv(ref bool ok, ref bool closed)
    {
        T t;
        !<<
        select {
        case l_t, *l_ok = <-this.ch:
            *l_closed = !*l_ok
        default:
            *l_ok = false
            *l_closed = false
        }
        !>>
        return t;
    }

    !<<
    ch chan @<<{T}>>
    !>>
}
