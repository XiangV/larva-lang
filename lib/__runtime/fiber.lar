import fiber;

!<<

import (
    "context"
    "time"
)

type lar_go_stru_fiber struct {
    name   string
    ctx    context.Context
}

func (lar_fiber *lar_go_stru_fiber) throw_when_canceled() {
    select {
    case <-lar_fiber.ctx.Done():
        err := lar_fiber.ctx.Err()
        if err != nil {
            lar_func_@<<:throw>>(lar_fiber, &lar_cls_@<<fiber.Canceled>>{
                m__is_timeout: err == context.DeadlineExceeded,
            })
        }
    default:
    }
    lar_func_@<<:throw>>(lar_fiber, lar_str_from_go_str("调用lar_fiber.throw_when_canceled()时fiber未被正确取消"))
}

func lar_go_func_new_fiber(lar_fiber *lar_go_stru_fiber, name string, is_worker bool, timeout_nano int64) (
    new_lar_fiber *lar_go_stru_fiber, cancel context.CancelFunc) {
    var (
        par_ctx context.Context
        ctx     context.Context
    )
    if is_worker {
        par_ctx = lar_fiber.ctx
    } else {
        par_ctx = context.Background()
    }
    if timeout_nano > 0 {
        ctx, cancel = context.WithTimeout(par_ctx, time.Duration(timeout_nano))
    } else {
        ctx, cancel = context.WithCancel(par_ctx)
    }

    new_lar_fiber = &lar_go_stru_fiber{
        name: name,
        ctx:  ctx,
    }

    return
}

!>>
