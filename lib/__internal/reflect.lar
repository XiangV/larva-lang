!<<

import (
    "fmt"
    "reflect"
)

//larva反射接口，所有被编译的类、闭包（相当于匿名类）都要实现这个接口，由编译器保证
type lar_reflect_intf interface {
    lar_reflect_type_name()     *lar_cls_@<<:String>>   //返回类名
    lar_reflect_can_new_empty() bool                    //是否支持new一个空对象（所有字段为零值）
    lar_reflect_new_empty()     lar_intf_@<<:Any>>      //new一个空对象并返回，若类不支持此操作则返回nil
}

//字段信息
type lar_reflect_field_info_type {
    tn      *lar_cls_@<<:String>>
    zv      lar_intf_@<<:Any>>
    name    *lar_cls_@<<:String>>
    tags    []*lar_reflect_field_tag_type
}

//字段tag
type lar_reflect_field_tag_type {
    name    string
    value   string
}

//基础类型的名字定义
var (
    lar_reflect_type_name_nil_intf  = lar_str_from_go_str("<nil>")
    lar_reflect_type_name_bool      = lar_str_from_go_str("bool")
    lar_reflect_type_name_schar     = lar_str_from_go_str("schar")
    lar_reflect_type_name_char      = lar_str_from_go_str("char")
    lar_reflect_type_name_short     = lar_str_from_go_str("short")
    lar_reflect_type_name_ushort    = lar_str_from_go_str("ushort")
    lar_reflect_type_name_int       = lar_str_from_go_str("int")
    lar_reflect_type_name_uint      = lar_str_from_go_str("uint")
    lar_reflect_type_name_long      = lar_str_from_go_str("long")
    lar_reflect_type_name_ulong     = lar_str_from_go_str("ulong")
    lar_reflect_type_name_float     = lar_str_from_go_str("float")
    lar_reflect_type_name_double    = lar_str_from_go_str("double")
)

!>>

final String
    REFLECT_TYPE_NAME_GO_TYPE_PREFIX = "<GoType ",
    REFLECT_TYPE_NAME_GO_TYPE_SUFFIX = ">",
;

public String reflect_type_name(GoAny a)
{
    !<<
    switch l_a.(type) {
    case nil:
        return lar_reflect_type_name_nil_intf
    case bool:
        return lar_reflect_type_name_bool
    case int8:
        return lar_reflect_type_name_schar
    case uint8:
        return lar_reflect_type_name_char
    case int16:
        return lar_reflect_type_name_short
    case uint16:
        return lar_reflect_type_name_ushort
    case int32:
        return lar_reflect_type_name_int
    case uint32:
        return lar_reflect_type_name_uint
    case int64:
        return lar_reflect_type_name_long
    case uint64:
        return lar_reflect_type_name_ulong
    case float32:
        return lar_reflect_type_name_float
    case float64:
        return lar_reflect_type_name_double
    }
    lri, ok := l_a.(lar_reflect_intf)
    if ok {
        return lri.lar_reflect_type_name()
    }
    return lar_str_from_go_str(
        fmt.Sprintf("%s%s%s",
                    lar_str_to_go_str(lar_gv_@<<REFLECT_TYPE_NAME_GO_TYPE_PREFIX>>), reflect.TypeOf(l_a).String(),
                    lar_str_to_go_str(lar_gv_@<<REFLECT_TYPE_NAME_GO_TYPE_SUFFIX>>)))
    !>>
}

public bool is_go_type_name(String tn)
{
    return tn.has_prefix(REFLECT_TYPE_NAME_GO_TYPE_PREFIX) && tn.has_suffix(REFLECT_TYPE_NAME_GO_TYPE_SUFFIX);
}
