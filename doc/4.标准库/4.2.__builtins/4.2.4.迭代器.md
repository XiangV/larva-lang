# **迭代器**

本节用于说明Larva的迭代器机制

## **迭代器概述**

迭代器机制是一种常见的用于遍历容器的机制，也可用于指示数据查找结果之类的场景。简单说，就是有一个独立的对象指示了容器中的某个“数据位置”，
通过迭代器可以直接存取对应位置的数据，一般来说，一个容器中的所有数据的迭代器构成了一个抽象的线性表结构，任意一个迭代器有其对应的前驱和后继迭代器

## **迭代器接口**

Larva采用接口+规范的方式规定了迭代器类的实现规则，将可迭代的容器数据视为一个抽象的带前后边界的线性表，迭代器则是“指向”表中某一项或边界

边界可以理解为线性表前后各有一个虚拟的数据项，指向它们的迭代器本身是合法的，但逻辑上是越界的，如果线性表为空，则依然有前后边界两个虚拟数据项

* *Note*：迭代器是一个对象，并不是普通的局部引用或指针，但以下文档中我们统一用“指向”一词；另外迭代器指向的应该是数据项或边界，
但我们为了方便起见，也会简单说其“指向数据”

迭代器接口是如下几个内建接口：

* `Iter<E>`

    基础迭代器接口，泛型参数`E`为迭代器可迭代出的元素类型
    ```
    public interface Iter<E>
    {
        /*
        获取当前迭代器指向的数据，若迭代器越界、失效则抛出对应异常
        */
        public E get();

        /*
        判断迭代器是否已位于后边界，若迭代器失效，则应抛出IterDirty异常
        */
        public bool after_end();

        /*
        将迭代器向后移动，即指向当前数据的后继
        需要注意的点：
        - 如果当前元素已经是最后一个元素了，inc也应成功执行并指向后边界
        - 如果已经指向了后边界，则强烈建议inc方法抛出IterOutOfRange异常，而不是静默地保持指向并返回
        - inc是直接改变当前迭代器对象对数据的指向，并不是创建并返回一个指向下一个数据的新迭代器
        */
        public void inc();
    }
    ```
    实现了`Iter<E>`接口的迭代器即可做从前往后的迭代，一般代码中使用到的迭代遍历都可采用这种方式，`Iter<E>`不但是内建库定义的接口，
    而且也是语法规范的一部分，如‘3.13.语句’一节所述，`foreach`语句的语法规范就依赖了`Iter<E>`接口的方法签名

* `ReversibleIter<E>`

    双向迭代器接口，在`Iter<E>`基础上扩展了反向遍历的相关操作
    ```
    public interface ReversibleIter<E>
    {
        /*
        继承Iter<E>的所有方法
        */
        Iter<E> usemethod;

        /*
        判断迭代器是否已位于前边界，若迭代器失效，则应抛出IterDirty异常
        */
        public bool before_begin();

        /*
        将迭代器向前移动，即指向当前数据的前驱，相当于inc的反操作，除指向改变的方向不同外，各规则和inc相同
        */
        public void dec();
    }
    ```
    需要特别说明的一点：前边界和第一个数据项互为前驱和后继，这意味着对指向前边界的迭代器做`inc`操作，它将指向第一个元素，同样的，
    对后边界做`dec`操作后，它将指向最后一个数据项

*Note*：
* Larva的迭代器采用尽量简化的方式实现，这有利于迭代器实现的灵活性，
例如`Iter`和`ReversibleIter`分开（早期版本曾规定迭代器必须能反向移动，后面更简化了）、只提供`get`取数据接口等
* `before_begin`和`after_end`两个名字看起来有点奇怪，其实是因为历史原因，一开始是这样取名的，
后来由于“位于第一个元素之前”和“最后一个元素之后”的概念解释起来有点绕，后面才引入边界虚拟数据项的概念

## **迭代器相关的异常**

以下有无参构造方法并且无`str`方法说明的均为空异常实现，即错误信息为空串

* `IterOutOfRange`

    这个异常指示迭代器已越界
    ```
    public class IterOutOfRange
    {
        public IterOutOfRange()
    }
    ```
    当试图通过一个已越界的迭代器存取数据，或其他无效操作时抛出

* `IterDirty`

    这个异常指示迭代器已失效
    ```
    public class IterDirty
    {
        public IterDirty()
    }
    ```
    当试图通过一个已失效的迭代器做操作时抛出，例如`util.HashMap`在哈希表rehash后就会导致所有迭代器失效

* `UnsupportedIterOper`

    这个异常指示不支持的迭代器操作
    ```
    public class UnsupportedIterOper
    {
        public UnsupportedIterOper()
    }
    ```
    一般来说，一个合法的迭代器应完整实现`Iter<E>`等接口规定的所有规范，但特殊情况下如果实现者并不想提供某些操作，例如只能`get`不能`inc`，
    则可在不提供实现的方法内部抛出这个异常，从方法签名上依然保证是一个合法的迭代器

## **可迭代对象**

Larva对于获取容器迭代器的方式也有统一规范，但这并不是语法上的，而是一种约定

约定规则：一个容器如提供迭代器遍历功能，需提供签名为`[public] T iter()`的方法，详细说明：
* public修饰可选
* 返回的类型`T`是指某迭代器类型，需实现针对某个类型`E`的`Iter<E>`接口
* 返回的迭代器对象指向对应类型的“初始迭代器”，一般是指迭代线性表中第一个元素（如线性表为空，则直接指向后边界）

我们将符合这个规则的类的对象实例称为可迭代对象，需要注意可迭代对象和迭代器本身的区别，可通过前者的`iter`方法获取后者，
当然迭代器类也可以通过实现`iter`方法来使自己的对象实例可迭代

由于Larva不支持协变和抗变，无法通过一个统一的接口来规范可迭代对象，因为`iter`方法的返回类型并不确定，当然也可以设计为Java的那种模式，
即将`iter`方法的签名统一为`Iter<E> iter()`，但Larva并没有选择强制统一这个方法签名

不过，Larva的风格是多使用迭代器而非可迭代对象，因此从实践上讲，迭代器的可迭代性不是必要的，统一的可迭代接口也不是特别必要

## **数组迭代器**

数组的迭代器类型`ArrayIter<E>`也属于`__builtins`模块，但逻辑上和数组接近，因此在‘4.1.__array’一节中说明，请参考相关章节内容
