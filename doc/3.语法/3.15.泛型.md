# **泛型**

## **概述**

和C++、Java等语言一样，Larva也支持泛型编程，包括泛型类、泛型接口和泛型函数等语法元素

从定义来说，泛型可被认为是将类型本身作为参数的一种语法设计，在Larva中，泛型语法是指一个带有泛型参数的语法元素，
在指定的泛型参数的类型下实例化为一个具体的泛型实例

## **语法**

* 泛型元素的定义和对应的普通元素类似，区别在于元素名字（类、接口或函数名）后跟泛型参数列表

    泛型参数列表是由尖括号括起来的名字列表，在泛型语法元素内部可直接作为一个类型使用，泛型参数列表不能为空

    Larva在设计上对名字冲突和名字隐藏的限制比较严格，由于泛型参数可在泛型类或泛型函数中直接使用，
    因此它不能和当前文件中导入的模块名、当前模块的模块元素以及`__builtins`模块的public元素重名

* 对泛型语法元素实例化时，在其名字后加尖括号括起的类型列表即可，类型数量必须匹配对应泛型语法元素的泛型参数数量

    类型参数可是任何类型，当然也包括泛型类或泛型接口的实例，即泛型是可嵌套的，例如`A<B<C<int>, D>>`

    泛型类和泛型接口本身不是一个实际的类型，只有在实例化后才能作为一个类型使用，即不可直接使用

    *Note*：两个反尖括号在词法分析的时候，根据最长子串原则会被解析为右移符号，编译器在语法分析阶段会根据实际代码判断其具体含义，
    由于泛型参数只能传入类型，因此不存在歧义

* 泛型函数的调用中可指定泛型参数调用其泛型实例，也可省略泛型参数，通过函数参数的类型进行推导，具体推导规则见下一小节

* 除了可以将泛型参数作为类型使用外，泛型语法元素的具体语法和正常的类、接口、函数是一样的

* 类方法和函数的实现中可使用编译控制命令实现针对不同类型使用不同代码，即实现类似C++偏特化和SFINAE的机制，详细语法和规则见‘3.16.编译控制命令’

* 示例：

    泛型类示例：
    ```
    class A<T>
    {
        T t;
    }
    ```
    `A`是一个泛型类，其有一个泛型参数为`T`，可在用到类型的时候使用其泛型实例，例如`A<int>`、`A<Any>`等都是`A`的泛型类实例，
    它们在本质上和一个普通类没有什么区别，可以认为编译器将其实例化为这两个类：
    ```
    class A_int
    {
        int t;
    }

    class A_Any
    {
        Any t;
    }
    ```
    实际上Larva编译器就是这么做的，Larva对泛型的实现目前是采用类似C++的模板的方式，进行代码替换和泛型实例的代码生成

    泛型函数的规则也是类似，例：
    ```
    T f<T, U>(T t)
    {
        U u = cast<U>(1.23);
        return t + cast<T>(u);
    }

    U g<T, U>(U u)
    {
        return f<U, T>(u);
    }

    public void main()
    {
        var r = f<int, long>(123);
        println("%T:%s".(r, r));    //输出“int:124”
        //g<String, int>(123);      //这句如果不注释会编译失败
    }
    ```
    `f`是一个有两个泛型参数的泛型函数，在`main`中通过制定泛型参数的类型对其进行了实例化并进行调用，实际等于是生成了一个对应的函数，
    就像上面的泛型类的实例化一样，`g`也是类似，在`g`中可通过泛型参数去实例化`f`（当然实际实例化是在`g`的实例中，这时候`T`和`U`已经是具体的类型了）

    无论是哪种泛型实例，都需要保证实例化后的语法元素可以被编译通过，否则编译报错，例如上面的例子中，如果将注释的这一句去掉注释进行编译，
    则会报类似如下的错误：
    ```
    错误：文件[/home/xtlisk/larva/tmp/tmp.lar]行[3]列[16] 无效的强制类型转换：‘double’到‘__builtins.String’
    泛型实例构造链：
    文件[/home/xtlisk/larva/tmp/tmp.lar]行[16]列[5] tmp.g<__builtins.String, int>
    文件[/home/xtlisk/larva/tmp/tmp.lar]行[9]列[12] tmp.f<int, __builtins.String>
    ```
    即在实例化为具体函数并进行编译的时候发现语法错误，则对具体位置报错，同时显示泛型实例的构造链
    （自上而下是`main`中实例化`g<String, int>`，然后后者中实例化`f<int, String>`），方便查问题和修复bug

    *Note*：为方便查问题，编译报错信息会将`__builtins`模块名前缀也打印出来

    泛型接口的语法和用法类似，就不举例了

## **泛型类型推导**

Larva支持在调用泛型函数的时候不指定泛型参数，而由编译器通过函数参数的实际类型进行推导

例如：
```
void f<T>(T t)
{
    println(t);
}

public void main()
{
    f("hello");     //f<String>("hello")

    Any a = 123;
    f(a);           //f<Any>(a)
}
```
这个例子在调用`f`的时候，如果不指定泛型参数的类型列表，则编译器可以通过传入的函数参数的类型进行推导，代码注释中是其等价的调用

详细说明：

* 类型推导使用的是实参表达式的类型，而非其具体值，例如`f(cast<Any>(123L))`，是用实参类型`Any`去做推导算法，而非`long`

* 必须能根据规则推导出所有泛型参数的类型，否则报错

    例：
    ```
    void f<T>()
    {
    }

    public void main()
    {
        f();    //编译错误，无法推导出T的类型，必须指定
    }
    ```

* 泛型参数的类型列表要么完全指定，要么不指定而完全依赖推导，不能只指定部分

    * *Note*：主要是不想把语法设计得太过复杂，如果真有这种需求，可以选择写一个临时函数，完全用类型推导来实现
    
        例：
        ```
        void f<T, U>(U u)
        {
        }

        void g<T, U>(T t, U u)  //这个参数t唯一的用处就是可以推导出T的类型
        {
            f<T, U>(u);
        }

        public void main()
        {
            //如果f的U只能通过类型推导确定的话，无法直接调用f的，因为没法指定T，可以用一个函数g来做媒介
            g(zero_value<int>(), "hello");
        }
        ```
        当然就这个例子来说，我们可以直接调用`f<int, String>`，但有的时候我们无法从语法中直接得到明确类型信息，就必须应用类型推导，
        见**类型推导的必要性**小节的说明

* 泛型参数的类型推导结果不能为`void`

    * *Note*：`void`并不是一个真正的类型，但是由于可作为函数或方法的返回类型说明，根据推导规则是可能有这样的结果的

* 由于参数的`ref`修饰不作为类型的一部分，因此不影响推导结果，但各实参的`ref`修饰必须和形参的一致，且不能使用`ref _`

    * 注意，就算形参类型不需要推导，也不能在类型推导时在实参中使用`ref _`，可定义临时变量来代替

        例如：
        ```
        void f<T>(T t, ref int i)
        {
        }

        public void main()
        {
            //这样会报语法错误
            f("", ref _);

            //正确做法
            int i;
            f("", ref i);
        }
        ```

        * *Note*：这种规定其实并没有什么语法设计上的特殊意义，只是因为类型推导和参数检查在编译器中是两个不同模块，实现上不方便耦合在一起，
        而且要检查一个形参类型是否不含泛型参数也较为麻烦

* 对于形参类型就是泛型参数本身且无`ref`修饰的情况，推导算法并不会直接推导出其结果，而是综合其他推导结果，从中选择出一个“兼容”所有结果的类型，
这里的“兼容”是指可以隐式转换，但是int字面量和nil字面量除外

    例：
    ```
    void f<T>(T t1, T t2)
    {
    }

    public void main()
    {
        f(1.234, cast<Any>(123));   //1 f<Any>
        f(1.234, 123L);             //2 编译错误
        f(123, 456);                //3 编译错误
        f(nil, nil);                //4 编译错误
        f(+123, +456);              //5 f<int>
    }
    ```
    几个调用的说明：

    1. 推导为`f<Any>`，因为两个实参类型都匹配泛型参数`T`，一个是`double`一个是`Any`，由于`Any`兼容`double`，因此以它为推导结果
    2. 编译错误，因为两个推导类型`double`和`long`互不兼容，编译器也不会凭空猜一个`f<Any>`，因为很多时候不止一个共同的兼容结果，因此报错
    3. 编译错误，不能用int字面量
    4. 编译错误，不能用nil字面量
    5. 推导为`f<int>`，因为int字面量做计算后表达式即确定为`int`类型，注意两个类型都需要是`int`，即便一个是`int`一个是int字面量也不能隐式转换

    * *Note*：Larva对于int字面量的推导限制显得有些苛刻，主要是为了避免一些隐晦的错误并提高可读性，从而强制要求程序员多写几个字

* 若形参类型带`ref`修饰，或者，形参类型是一个含有当前泛型函数的泛型参数的泛型类或泛型接口且实参的类型是同一个泛型类或接口的实例，
则进行模式匹配的精确推导

    * 由于数组实际上是泛型类`__array.Arr<E>`的泛型实例，因此也适用这个规则

    * 模式匹配支持形参类型的泛型嵌套任意多层

    * 由于Larva不支持协变抗变机制，模式匹配的结果为精确结果，
    只考虑上一条中的“形参类型为泛型参数且无`ref`修饰”的推导结果向精确结果隐式转换的兼容情况

        例如：
        ```
        void f<T>(ref T r, T t)
        {
        }

        void g<T>(T[] a, Catched<T> c)
        {
        }

        public void main()
        {
            int i;
            Any a;

            f(ref i, a);                                        //1 编译错误
            f(ref a, i);                                        //2 f<Any>
            g(new String[10], cast<Catched<Throwable>>(nil));   //3 编译错误
            g(cast<String[]>(nil), cast<Catched<String>>(nil)); //4 g<String>
        }
        ```
        几个调用的说明：

        1. 通过第一个实参`ref i`已经能精确推导出`f<int>`了，因此第二个参数的类型错误
        2. 通过第一个实参`ref a`精确推导出`f<Any>`，第二个参数推导出的`int`可以被`Any`兼容，因此通过
        3. 两个参数都通过模式匹配精确推导，不考虑兼容性，`String`和`Throwable`不同，编译错误
        4. 精确推导结果一致，成功推导出`g<String>`

* 若形参类型是一个不含`ref`修饰的，含有当前泛型函数的泛型参数的泛型接口类型，且能确定其方法集合，且实参类型实现了这个方法集合，
则可根据方法签名做模式匹配

    * 方法签名模式匹配的结果为精确结果

        例：
        ```
        void f<T>(Iter<T> it)
        {
        }

        public void main()
        {
            f(new int[10].iter());      //1 f<int>
            f([]{
                public long get()
                {
                }
                public bool after_end()
                {
                }
                public void inc()
                {
                }
            });                         //2 f<long>
        }
        ```
        几个调用的说明：

        1. 实参的类型为`ArrayIter<int>`，按方法模式匹配`Iter<T>`可推导出`f<int>`
        2. 类似1，只不过传入的是一个闭包对象，同样通过按方法模式匹配推导出`f<long>`

    * 形参泛型接口类型的方法集合必须是确定的，只有这样才有推导的意义

        不确定的方法集合的情况只有一种，即泛型接口中直接对泛型参数做`usemethod`，例如：
        ```
        interface I<T>
        {
            T usemethod;
        }

        void f<T>(I<T> i)
        {
        }

        public void main()
        {
            f("");          //1 编译失败，无法进行推导

            I<Throwable> i;
            f(i);           //2 f<Throwable>
        }
        ```
        这个例子中，由于接口`I<T>`的方法集合依赖于`T`，通过实参的方法进行匹配是无法确定T的类型的，因为可以有很多个结果，
        因此第一个调用会编译失败；而第二个调用可以成功推导，因为实参的类型就是`I<T>`的泛型实例，可以不做方法模式匹配，
        直接用类型做模式匹配即可得到结果了

    * 解析出的类型不能是`void`

        例：
        ```
        interface I<T>
        {
            T f();
        }

        void f<T>(I<T> i)
        {
        }

        public void main()
        {
            f([]{
                void f()
                {
                }
            });             //编译错误
        }
        ```

### **类型推导的必要性**

从上面的说明来看，类型推导似乎只是一种简化开发的手段，省略了开发者写泛型函数的类型参数列表的麻烦，但实际上它并不仅是一种锦上添花的手段，
而是有存在的必要性的，因为在开发泛型代码时，有时我们并不能在语法层面明确写出一个具体的类型，或写起来很麻烦，下面举几个例子来说明

例如，假设我们想对一个类型的参数做遍历，然后依次以其元素调用某个处理函数，则可以这样写：
```
void deal_with_elem<E>(E e)
{
    ...
}

void f<T>(T t)
{
    foreach (var e: t)
    {
        deal_with_elem(e);
    }
    ...
    var a = new T[10];
    ...
}
```
显然这里使用了类型推导生成了某个`deal_with_elem<E>`的实例，假如没有类型推导，由于语法上没法从`T`推导出其`get`方法的返回类型，
因此无法写出`deal_with_elem`实例化所需要的泛型参数类型

当然，我们可以将`f`的参数改为`Iter<E>`接口，但注意下面我们还直接用到了`T`本身，因此我们可能需要指定两个泛型类型来解决这个问题：
```
void f<T, E>(T t)
{
    foreach (var e: it)
    {
        deal_with_elem<E>(e);
    }
    ...
    var a = new T[10];
    ...
}
```
然后在调用`f<T, E>`的时候，同时指定两个泛型类型，分别代表`t`本身的类型和`t.get`的返回类型，这样做非常麻烦，
假设我们在一个泛型函数中不但用到了泛型类型`T`，还用到了和它相关的，例如它的多个方法的返回类型或参数的类型，如果没有类型推导来“解析”出这些类型，
那么相关的泛型函数签名会非常复杂

以上的例子虽然麻烦了点，但是至少理论上是可以不用类型推导来直接实现的，而有的时候我们可能必须依赖类型推导，
例如在不清楚具体泛型的嵌套层数的情况下，解析出其最后一层的类型：
```
class A<T>
{
}

void g<T>(A<T> a)
{
#use
    g(zero_value<T>());
#else
    println(type_name<T>());
#enduse
}

void f<T>()
{
    g(zero_value<T>());
}

public void main()
{
    f<A<int>>();                    //输出“int”
    f<A<A<A<long>>>>();             //输出“long”
    f<A<A<A<A<A<Callable>>>>>>();   //输出“Callable”
}
```
注意这里函数`g<T>`的实现中使用了编译控制命令`#use`，含义是“如果对应代码块编译失败，则使用`#else`下的代码块”，于是根据类型推导的规则，
当类型`T`是一个泛型类`A`的泛型实例时，递归调用`g`，否则`#use`的代码块编译失败，在`#else`中直接打印`T`类型名，
从而实现了解析任意多层的`A<...>`的泛型嵌套的功能

`#use`的详细说明见‘3.16.编译控制命令’；`zero_value`和`type_name`是内建函数，见‘4.2.__builtins’的文档说明

通过类型推导配合编译控制命令解析类型是常见的做法（虽然需求场景不一定常见），一个实际一点的例子是标准库中数组的`deep_copy`方法，
它是通过一个内部的泛型函数实现的：
```
T[] deep_copy<T>(T[] a)
{
    if (a === nil)
    {
        return nil;
    }

    long sz = a.size();
    var b = new T[sz];

    for (long i = 0; i < sz; ++ i)
    {
#if typeisarray(T)
        b[i] = deep_copy(a[i]);
#else
        b[i] = a[i];
#endif
    }

    return b;
}
```
和上面的例子类似（改用了`#if`编译控制命令），这里可以递归任意维度的数组进行深拷贝

*Note*：对于这类问题当然也可以选择一些“直接推导”的语法来设计Larva，其实早期是有类似想法的：
```
void f<T>(T t)
{
    foreach (var e: it)
    {
        deal_with_elem<typeof(T.get())>(e);
    }
    ...
    var a = new T[10];
    ...
}
```
这有点类似C++的decltype，不过我认为不够简洁直观，上面的`typeof(T.get())`还好，如果我想取`T`的方法`m`的第三个参数的类型，
并断言它是一个数组类型并取其元素类型，那么怎么写呢？写成`typeof(T.m.3[])`这种鬼画符就有点难看了，维护性也不好，综合考虑下还是选择用类型推导了，
当然类型推导也并不能保证解决所有奇奇怪怪的需求，只是个人认为的一个比较平衡的选择，实在不行的话，Larva还有反射机制，见标准库的相关章节

### ***Note***

由于类型推导机制的存在，在某些情况下就允许我们使用到正常无法访问到的类型

* 获取并使用私有类型

    例：
    ```
    //模块alpha------------------------------------
    class A
    {
        public int a;
    }

    public A f()    //注意这个public是修饰f的，A是返回类型
    {
        return new A();
    }

    //模块beta------------------------------------
    import alpha;

    public void main()
    {
        var a = alpha.f();  //正确，虽然我们无法直接使用alpha.A，但是可以调用alpha.f并用var来接收其结果，a的类型就是alpha.A
        f(a);               //利用类型推导，直接生成泛型函数f的实例f<A>
    }

    void f<T>(T t)
    {
        T a;    //main中通过f(a)调用推导出T为alpha.A，就可以直接用了
    }
    ```
    函数`alpha.f`是public的，通过调用它并使用类型推导，我们可以直接获取到`alpha.A`这个正常权限无法访问到的类，尽管看上去不合理，
    但Larva并不认为这是一个语法缺陷，而是`alpha.f`的设计缺陷，即一个public函数或方法的返回类型是非public，本身就是一种模块设计的问题

* 获取闭包对象

    例：
    ```
    void test_closure<T>(T t)
    {
        //main中的代码将c传入后，T被推导为c的闭包类型
        t.f();

        //可以直接定义T的变量，但是无法直接赋值为其他闭包，只能为同类型的值或nil
        T x = t;
        x.f();
        x = nil;
        x.f();      //值为nil的闭包对象实例调用方法会导致程序崩溃
    }

    public void main()
    {
        //c的类型就是闭包类型本身
        var c = []{
            void f()
            {
                println("closure_of_main.f");
            }
        };
        test_closure(c); //无法显式指定泛型参数为闭包类型，但可以通过类型推导
    }
    ```
    闭包类型可看做是一个内部匿名类型，每个`[]{}`定义的位置都确定了一个对应的闭包类型（其内部类型名本身也包含所在的文件和行列位置），
    只有同一个闭包类型可以互相赋值，可以赋值为nil，但是值为nil的闭包没有任何意义，对其调用方法会导致崩溃
