# **泛型**

## **概述**

和C++、Java等语言一样，Larva也支持泛型编程，包括泛型类、泛型接口和泛型函数等语法元素

从定义来说，泛型可被认为是将类型本身作为参数的一种语法设计，在Larva中，泛型语法是指一个带有泛型参数的语法元素，
在指定的泛型参数的类型下实例化为一个具体的泛型实例

## **语法**

* 泛型元素的定义和对应的普通元素类似，区别在于元素名字（类、接口或函数名）后跟泛型参数列表

    泛型参数列表是由尖括号括起来的名字列表，在泛型语法元素内部可直接作为一个类型使用，泛型参数列表不能为空

    Larva在设计上对名字冲突和名字隐藏的限制比较严格，由于泛型参数可在泛型类或泛型函数中直接使用，
    因此它不能和当前文件中导入的模块名、当前模块的模块元素以及`__builtins`模块的public元素重名

* 对泛型语法元素实例化时，在其名字后加尖括号括起的类型列表即可，类型数量必须匹配对应泛型语法元素的泛型参数数量

    类型参数可是任何类型，当然也包括泛型类或泛型接口的实例，即泛型是可嵌套的，例如`A<B<C<int>, D>>`

    泛型类和泛型接口本身不是一个实际的类型，只有在实例化后才能作为一个类型使用，即不可直接使用

    *Note*：两个反尖括号在词法分析的时候，根据最长子串原则会被解析为右移符号，编译器在语法分析阶段会根据实际代码判断其具体含义，
    由于泛型参数只能传入类型，因此不存在歧义

* 泛型函数的调用中可指定泛型参数调用其泛型实例，也可省略泛型参数，通过函数参数的类型进行推导，具体推导规则见下一小节

* 除了可以将泛型参数作为类型使用外，泛型语法元素的具体语法和正常的类、接口、函数是一样的

* 类方法和函数的实现中可使用编译控制命令实现针对不同类型使用不同代码，即实现类似C++偏特化和SFINAE的机制，详细语法和规则见‘3.16.编译控制命令’

* 示例：

    泛型类示例：
    ```
    class A<T>
    {
        T t;
    }
    ```
    `A`是一个泛型类，其有一个泛型参数为`T`，可在用到类型的时候使用其泛型实例，例如`A<int>`、`A<Any>`等都是`A`的泛型类实例，
    它们在本质上和一个普通类没有什么区别，可以认为编译器将其实例化为这两个类：
    ```
    class A_int
    {
        int t;
    }

    class A_Any
    {
        Any t;
    }
    ```
    实际上Larva编译器就是这么做的，Larva对泛型的实现目前是采用类似C++的模板的方式，进行代码替换和泛型实例的代码生成

    泛型函数的规则也是类似，例：
    ```
    T f<T, U>(T t)
    {
        U u = cast<U>(1.23);
        return t + cast<T>(u);
    }

    U g<T, U>(U u)
    {
        return f<U, T>(u);
    }

    public void main()
    {
        var r = f<int, long>(123);
        println("%T:%s".(r, r));    //输出“int:124”
        //g<String, int>(123);      //这句如果不注释会编译失败
    }
    ```
    `f`是一个有两个泛型参数的泛型函数，在`main`中通过制定泛型参数的类型对其进行了实例化并进行调用，实际等于是生成了一个对应的函数，
    就像上面的泛型类的实例化一样，`g`也是类似，在`g`中可通过泛型参数去实例化`f`（当然实际实例化是在`g`的实例中，这时候`T`和`U`已经是具体的类型了）

    无论是哪种泛型实例，都需要保证实例化后的语法元素可以被编译通过，否则编译报错，例如上面的例子中，如果将注释的这一句去掉注释进行编译，
    则会报类似如下的错误：
    ```
    错误：文件[/home/xtlisk/larva/tmp/tmp.lar]行[3]列[16] 无效的强制类型转换：‘double’到‘__builtins.String’
    泛型实例构造链：
    文件[/home/xtlisk/larva/tmp/tmp.lar]行[16]列[5] tmp.g<__builtins.String, int>
    文件[/home/xtlisk/larva/tmp/tmp.lar]行[9]列[12] tmp.f<int, __builtins.String>
    ```
    即在实例化为具体函数并进行编译的时候发现语法错误，则对具体位置报错，同时显示泛型实例的构造链
    （自上而下是`main`中实例化`g<String, int>`，然后后者中实例化`f<int, String>`），方便查问题和修复bug

    *Note*：为方便查问题，编译报错信息会将`__builtins`模块名前缀也打印出来

    泛型接口的语法和用法类似，就不举例了

## **泛型类型推导**

Larva支持在调用泛型函数的时候不指定泛型参数，而由编译器通过函数参数的实际类型进行推导

例如：
```
void f<T>(T t)
{
    println(t);
}

public void main()
{
    f("hello");     //f<String>("hello")

    Any a = 123;
    f(a);           //f<Any>(a)
}
```
这个例子在调用`f`的时候，如果不指定泛型参数的类型列表，则编译器可以通过传入的函数参数的类型进行推导，代码注释中是其等价的调用

详细说明：

* 类型推导使用的是实参表达式的类型，而非其具体值，例如`f(cast<Any>(123L))`，是用实参类型`Any`去做推导算法，而非`long`

* 必须能根据规则推导出所有泛型参数的类型，否则报错

    例：
    ```
    void f<T>()
    {
    }

    public void main()
    {
        f();    //编译错误，无法推导出T的类型，必须指定
    }
    ```

* 泛型参数的类型列表要么完全指定，要么不指定而完全依赖推导，不能只指定部分

    * *Note*：主要是不想把语法设计得太过复杂，如果真有这种需求，可以选择写一个临时函数，完全用类型推导来实现
    
        例：
        ```
        void f<T, U>(U u)
        {
        }

        void g<T, U>(T t, U u)  //这个参数t唯一的用处就是可以推导出T的类型
        {
            f<T, U>(u);
        }

        public void main()
        {
            //如果f的U只能通过类型推导确定的话，无法直接调用f的，因为没法指定T，可以用一个函数g来做媒介
            g(zero_value<int>(), "hello");
        }
        ```
        当然就这个例子来说，我们可以直接调用`f<int, String>`，但有的时候我们无法从语法中直接得到明确类型信息，就必须应用类型推导，
        见**类型推导的必要性**小节的说明

* 泛型参数的类型推导结果不能为`void`

    * *Note*：`void`并不是一个真正的类型，但是由于可作为函数或方法的返回类型说明，根据推导规则是可能有这样的结果的

* 由于参数的`ref`修饰不作为类型的一部分，因此不影响推导结果，但各实参的`ref`修饰必须和形参的一致，且不能使用`ref _`

    * 注意，就算形参类型不需要推导，也不能在类型推导时在实参中使用`ref _`，可定义临时变量来代替

        例如：
        ```
        void f<T>(T t, ref int i)
        {
        }

        public void main()
        {
            //这样会报语法错误
            f("", ref _);

            //正确做法
            int i;
            f("", ref i);
        }
        ```

        * *Note*：这种规定其实并没有什么语法设计上的特殊意义，只是因为类型推导和参数检查在编译器中是两个不同模块，实现上不方便耦合在一起，
        而且要检查一个形参类型是否不含泛型参数也较为麻烦

* 对于形参类型就是泛型参数本身且无`ref`修饰的情况，推导算法并不会直接推导出其结果，而是综合其他推导结果，从中选择出一个“兼容”所有结果的类型，
这里的“兼容”是指可以隐式转换，但是int字面量和nil字面量除外

    例：
    ```
    void f<T>(T t1, T t2)
    {
    }

    public void main()
    {
        f(1.234, cast<Any>(123));   //1 f<Any>
        f(1.234, 123L);             //2 编译错误
        f(123, 456);                //3 编译错误
        f(nil, nil);                //4 编译错误
        f(+123, +456);              //5 f<int>
    }
    ```
    几个调用的说明：

    1. 推导为`f<Any>`，因为两个实参类型都匹配泛型参数`T`，一个是`double`一个是`Any`，由于`Any`兼容`double`，因此以它为推导结果
    2. 编译错误，因为两个推导类型`double`和`long`互不兼容，编译器也不会凭空猜一个`f<Any>`，因为很多时候不止一个共同的兼容结果，因此报错
    3. 编译错误，不能用int字面量
    4. 编译错误，不能用nil字面量
    5. 推导为`f<int>`，因为int字面量做计算后表达式即确定为`int`类型，注意两个类型都需要是`int`，即便一个是`int`一个是int字面量也不能隐式转换

    * *Note*：Larva对于int字面量的推导限制显得有些苛刻，主要是为了避免一些隐晦的错误并提高可读性，从而强制要求程序员多写几个字

* 若形参类型带`ref`修饰，或者，形参类型是一个含有当前泛型函数的泛型参数的泛型类或泛型接口且实参的类型是同一个泛型类或接口的实例，
则进行模式匹配的精确推导

    * 由于数组实际上是泛型类`__array.Arr<E>`的泛型实例，因此也适用这个规则

    * 模式匹配支持形参类型的泛型嵌套任意多层

    * 由于Larva不支持协变抗变机制，模式匹配的结果为精确结果，
    只考虑上一条中的“形参类型为泛型参数且无`ref`修饰”的推导结果向精确结果隐式转换的兼容情况

        例如：
        ```
        void f<T>(ref T r, T t)
        {
        }

        void g<T>(T[] a, Catched<T> c)
        {
        }

        public void main()
        {
            int i;
            Any a;

            f(ref i, a);                                        //1 编译错误
            f(ref a, i);                                        //2 f<Any>
            g(new String[10], cast<Catched<Throwable>>(nil));   //3 编译错误
            g(cast<String[]>(nil), cast<Catched<String>>(nil)); //4 g<String>
        }
        ```
        几个调用的说明：

        1. 通过第一个实参`ref i`已经能精确推导出`f<int>`了，因此第二个参数的类型错误
        2. 通过第一个实参`ref a`精确推导出`f<Any>`，第二个参数推导出的`int`可以被`Any`兼容，因此通过
        3. 两个参数都通过模式匹配精确推导，不考虑兼容性，`String`和`Throwable`不同，编译错误
        4. 精确推导结果一致，成功推导出`g<String>`

* 若形参类型是一个不含`ref`修饰的，含有当前泛型函数的泛型参数的泛型接口类型，且能确定其方法集合，且实参类型实现了这个方法集合，
则可根据方法签名做模式匹配

    * 方法签名模式匹配的结果为精确结果

        例：
        ```
        void f<T>(Iter<T> it)
        {
        }

        public void main()
        {
            f(new int[10].iter());      //1 f<int>
            f([]{
                public long get()
                {
                }
                public bool after_end()
                {
                }
                public void inc()
                {
                }
            });                         //2 f<long>
        }
        ```
        几个调用的说明：

        1. 实参的类型为`ArrayIter<int>`，按方法模式匹配`Iter<T>`可推导出`f<int>`
        2. 类似1，只不过传入的是一个闭包对象，同样通过按方法模式匹配推导出`f<long>`

    * 形参泛型接口类型的方法集合必须是确定的，只有这样才有推导的意义

        不确定的方法集合的情况只有一种，即泛型接口中直接对泛型参数做`usemethod`，例如：
        ```
        interface I<T>
        {
            T usemethod;
        }

        void f<T>(I<T> i)
        {
        }

        public void main()
        {
            f("");          //1 编译失败，无法进行推导

            I<Throwable> i;
            f(i);           //2 f<Throwable>
        }
        ```
        这个例子中，由于接口`I<T>`的方法集合依赖于`T`，通过实参的方法进行匹配是无法确定T的类型的，因为可以有很多个结果，
        因此第一个调用会编译失败；而第二个调用可以成功推导，因为实参的类型就是`I<T>`的泛型实例，可以不做方法模式匹配，
        直接用类型做模式匹配即可得到结果了

    * 解析出的类型不能是`void`

        例：
        ```
        interface I<T>
        {
            T f();
        }

        void f<T>(I<T> i)
        {
        }

        public void main()
        {
            f([]{
                void f()
                {
                }
            });             //编译错误
        }
        ```

### **类型推导的必要性**

todo

### **关于私有类型和闭包类型的推导**

todo
