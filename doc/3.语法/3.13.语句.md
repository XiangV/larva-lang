# **语句**

## **概述**

作为一个命令式的语言，Larva的语句是指在函数体或方法体中出现的命令，一个函数或方法的执行可看做是其包含的命令的顺序执行过程
（执行跳转或延迟执行等行为由语句自身决定，从整体原则上看语句是顺序执行的）

本文档中描述的语句概念是类似抽象语法树（AST）中的概念，首先概念比较宽泛，像变量定义之类的也算作语句概念，其次语句是可嵌套的，
即一条语句可能包含一个语句块，语句块中的语句列表是其一部分组成，例如：
```
public void main()
{
    int a = 0;  //语句1
    var b = 1;  //语句2

    //语句3，是一个代码块
    {
        println("%d %d".(a, b));    //语句3的代码块中的语句1
    }

    //语句4，是一个if语句
    if (a == b)
    {
        //语句4的第1个if部分
        return;             //语句1
    }
    else if (a < b)
    {
        //语句4的第2个if部分
        println("a < b");   //语句1
        return;             //语句2
    }
    else
    {
        //语句4的else部分
        println("a > b");   //语句1
        throw("error");     //语句2
    }
}
```
如示例的注释所描述的，只要是在某一层代码块中的一个独立“命令”，无论有多复杂，都算一条语句，
这个概念和代码块中变量的作用域概念也是可以很自然地结合在一起的

从形式上说，Larva的语句有两种，一种是结构含有代码块的，这种语句结尾不需要分号，例如循环、分支等，另一种是不带代码块的单条语句，
这种以分号`;`结尾，例如`return`、表达式语句等

空语句，即单独一个分号`;`也是合法的，但是编译器会给出警告

接下来的几个小节会将语句分类进行语法说明

## **代码块**

Larva语句列表中，用花括号括起来的独立代码块也是一条语句，这条语句的执行逻辑非常简单，就是将代码块中的语句依次执行，
相对于将其中的语句直接写在代码块所在的层次的做法，代码块的区别在于其中定义的变量的作用域在代码块内部，
可以让变量作用域的管理和逻辑更严谨有条理一些

例如：
```
void f()
{
    //这里用代码块或者直接写这几个println都没有什么区别
    {
        println("hello");
        println("world");
    }

    //这里的代码块限制了a的作用域
    {
        int a = 123;
        println(a);
    }
    //这里访问不到a了，如果上面不用代码块而是直接写语句，这里就可以访问到a
}
```
更多关于变量名作用域的说明可参考‘3.8.名字查找’

## **变量定义语句**

变量定义语句是指局部变量的定义和初始化，由于Larva的语句都是在函数或方法中，因此变量定义语句必然是局部变量

关于局部变量的语法、用法等详细说明请参考‘3.4变量和类型’、‘3.8.名字查找’、‘3.10.函数’几节，本节就不做重复说明了

*Note*：在很多语言中变量声明不作为实际的语句看待，而在Larva中由于变量可能被表达式初始化，即便没有显式初始化也会初始化为零值，
因此也是可以看做为可执行的语句的

## **赋值语句**

赋值语句的作用是对一个左值进行赋值操作，分为三类形式：
1. 直接赋值
1. 增量赋值
1. 自增自减

注意，和C++、Java之类的语言不同，赋值语句不是一个表达式，必须作为单独的语句使用

*Note*：如果写在语句块中，赋值语句后面当然是需要有分号的，不过下面不写，因为赋值语句还能用于`for`语句的域中，见后面for循环的语法说明

### **左值**

左值是指可以被放在赋值符号左边的表达式，不过结合赋值语句的定义好像有点循环论证，通俗说，左值表达式的求值的“最后一步”运算是一个直接取值的操作，
而非算出来的临时值，Larva中的左值表达式有以下几种：
* 全局变量名，用于左值时表示给对应的全局变量赋值
* 局部变量名，用于左值时表示给对应的局部变量赋值
* 数组下标运算`[]`，用于左值时表示给对应的数组元素赋值
* 取属性操作`.`，用于左值时表示给对应的对象实例的属性赋值

左值表达式需要“最后一步”是以上运算，具体运算分量可以很复杂，例如：`t.f().g()[x + y].a`

由于Larva中的类都是通过句柄引用操作，因此“临时”对象实例其实就相当于通过指针访问的堆上的对象实例，对其取属性的操作也是左值表达式，可以赋值，
只不过这个对象本身随即会回收罢了，例如`f().a = 1`是合法代码，对`f()`的返回对象的属性`a`赋值后，这个临时对象会被GC机制销毁，
因此这个赋值虽然语法正确，但并无实际意义（如果支持Finalizer的话可能是会用到修改后的值，这个操作就是有意义的了，不过Larva不打算支持）

`final`修饰的全局变量的名字从形式上也是左值，但是不可修改，因此也是不能用于赋值表达式或`ref`引用，后面的文档中为了方便，
不再强调是可变或不可变左值，根据上下文很容易区分

*Note*：左值还有一个使用场景是在调用函数或方法时，对于`ref`修饰的参数就需要传递一个左值的别名

### **直接赋值**

语法：`左值表达式 = 表达式`

直接赋值将右侧表达式的值赋予左侧的左值，表达式的值的类型必须和左值表达式的类型相同或可以隐式转换到后者

### **增量赋值**

语法：`左值表达式 增量赋值符 表达式`

增量赋值符由二元运算符和一个等号组成，包括：`+= -= *= /= %= &= |= ^= <<= >>=`

增量赋值运算相当于用左值表达式的值和表达式做运算，然后将运算结果赋予左值，基本上等同于：`左值表达式 = 左值表达式 运算 表达式;`，
区别在于增量赋值语句的左值表达式只求值一次，例如：
```
a[f()] += 1;            //f调用1次
a[f()] = a[f()] + 1;    //f调用2次
```

增量赋值的左值表达式类型和右侧表达式类型的规则和增量赋值符对应的二元运算的规则相同，可参考‘3.14.表达式’中的相关内容

### **自增自减**

自增自减用于快速对一个整数类型的左值做加一或减一操作，前缀和后缀两种形式都可以：
* 前缀形式：`{++ ¦ --} 左值表达式`
* 后缀形式：`左值表达式 {++ ¦ --}`

两种形式的作用是等价的，主要是兼容各种习惯，左值表达式必须是整数类型

## **表达式语句**

单独一个表达式也可作为语句（同样的在代码块中的话，其后需要分号），其含义是对此表达式求值，然后将结果简单抛弃掉，
因此只有表达式可能产生副作用的时候才有实质意义，为了防止一些低级错误，Larva规定如果表达式的最后一步运算不产生副作用，则不能作为语句，
只有三种类型的表达式运算可以作为表达式语句的最后一步求值：
1. 通过构造函数new一个对象
1. 调用方法
1. 调用函数

即只有类似调用的运算才可以，虽然通过构造函数new一个对象也是可以作为单独表达式（因为构造函数中可能有一些副作用操作，比如打印输出），
但从设计上来讲最好不要这么做，把新建对象和调用方法、函数操作从逻辑上分开

## **循环**

Larva支持三种循环语句：`while`、`for`和`foreach`

### **while**

语法：`while (条件表达式)`，后跟花括号括起来的循环体代码块

while循环的机制是在条件满足，即条件表达式结果为true的时候执行循环体，反复进行这个过程，每一轮都会计算一次条件表达式，条件表达式类型必须为`bool`

例：
```
public void main()
{
    int i = 0;
    while (i < 10)
    {
        println(i);
        ++ i;
    }
}
```

### **for**

语法：`for (初始化部分; 条件表达式; 增量操作部分)`，后跟花括号括起来的循环体代码块

for语句比较灵活，可以用于较为复杂的循环控制场景，其执行流程是：
1. 执行初始化部分
1. 计算条件表达式，若条件表达式结果为true，则执行循环体，否则结束循环
1. 执行完一次循环体后，执行增量操作部分，然后跳到上一步进行下一轮循环

* 初始化部分有两种形式：

    1. 变量定义形式，和局部变量定义形式相同，指定类型定义变量，或用`var`形式：

        * `类型 变量名 [= 初始化表达式][, 变量名 [= 初始化表达式]]...[,];`

        * `var 变量名 = 初始化表达式[, 变量名 = 初始化表达式]...[,];`

        *Note*：规则和局部变量也是一样的，即采用`var`形式时，必须指定初始化表达式，每个变量类型可以不同；而指定类型时，
        每个变量类型都是指定的类型，但可以省略初始化表达式来给变量赋默认的零值

        这种形式定义的变量的作用域被限制在for语句内部使用，即for语句的三个域以及循环体代码块，注意和循环体中定义的局部变量有差别，
        后者是每次执行循环体都新建子栈帧的，前者不是，在结合闭包的时候会有差别，具体可参考‘3.4.变量和类型’中的闭包一节

    1. 逗号分隔的表达式和赋值语句列表

        例如：`for (f(), g(), x = 3, y *= 4; ...; ...) {...}`，注意只能是表达式或赋值语句，不能是其他语句

* 条件表达式是一个值的类型为`bool`的表达式，根据上述流程，每次执行循环体前都会计算并判断

* 增量操作部分是逗号分隔的表达式和赋值语句列表

示例：
```
public void main()
{
    for (var i = 0, s = "%d".(i); i < 10 && s.len() < 10; ++ i, s = s.concat("%d".(i)))
    {
        println("%d %s".(i, s));
    }
}
```

### **foreach**

语法：`foreach ({var ¦ 类型} 变量名 : 迭代器表达式)`，后跟花括号括起来的循环体代码块

foreach语句一般用于迭代一个迭代器，规则说明：

* 循环变量必须是新定义的一个变量名，可以用`var`或指定类型，不能是一个左值表达式

    *Note*：如此规定是为了防止一些可能的误解并简化编译器开发，例如若有人写出这种代码：`foreach (a[f()]: it)`，
    循环变量究竟是先算出`f()`的返回值`x`然后将`a[x]`作为每次的循环赋值左值，还是每次都计算`f()`？虽然从语言设计上可以明确规定语义，
    但代码可读性是个问题

* 迭代器表达式在foreach开始执行的时候执行一次求值，其结果必须是一个合法迭代器，即实现了某种元素类型`E`为参数的泛型接口`__builtins.Iter<E>`，
这个接口的含义和用法具体可参考‘4.2.__builtins’的说明

* 若采用`var`形式定义循环变量，则循环变量的类型是迭代器元素的类型；若采用指定类型的形式定义循环变量，
则循环变量类型必须和迭代器元素类型相同或能从后者隐式转换

* foreach会对迭代器表达式求出的值进行反复迭代，每次将迭代出的值赋值给循环变量并开始执行循环体，若迭代结束则退出循环，
在循环体代码中改变循环变量的值**不影响**接下来的迭代

    例：
    ```
    public void main()
    {
        var a = new int[]{2, 3, 5, 7};

        foreach (var i: a.iter())
        {
            println(i);
        }

        /*
        上面循环等价如下代码：
        for (var _tmp_it = a.iter(), i = cast<int>(0); !_tmp_it.after_end(); _tmp_it.inc())
        {
            i = _tmp_it.get();
            println(i);
            //++ i;             //很容易看出若在这里改变i，对循环是没有影响的
        }
        */
    }
    ```
    可以看到foreach循环实际都可以通过手写for循环来实现，二者是等价的，foreach循环只是针对迭代场景的一种简化写法。
    从上面例子中的等价的for循环代码可以看出，如果循环体内部改变了循环变量`i`的值，对循环没有影响，因为循环是依靠`_tmp_it`这个隐式的临时变量

    和for循环相同，foreach循环的循环变量的作用域是foreach语句本身，但不是循环体代码块

### **break和continue**

在以上三种循环中，循环体的代码执行是按顺序执行其中的语句列表，Larva也支持用`break`和`continue`来提前结束循环或当次循环

break和continue语句语法很简单，就是这两个关键字本身，当然作为语句后面要加分号

break语句表示立即跳出循环语句，例如：
```
public void main()
{
    for (int i = 0; i < 10; ++ i)
    {
        if (i == 4)
        {
            break;  //i为4时退出当前for循环
        }
        println(i);
    }
    println("end");
}

/*
输出：
0
1
2
3
end
*/
```

continue语句结束当次循环，意即跳到下次循环：
1. 对于while循环，是跳到计算条件表达式的位置执行，之后继续while语句的流程
1. 对于for循环，是跳到流程的增量操作部分的位置进行执行，然后是计算条件表达式，之后继续for语句的流程
1. 对于foreach循环，是跳到迭代下一个元素并赋值给循环变量的位置执行，之后继续foreach语句的流程

需要注意的是break和continue只作用于当前循环，多层循环嵌套时和外层循环无关

### **需要注意的点**

需要特别注意的是循环体中定义的局部变量和闭包的相互作用，请参考‘3.4.变量和类型’中的闭包相关内容

## **分支语句**

Larva的分支语句用于实现根据条件选择不同分支执行的语法功能

语法：
```
if (条件表达式)
    代码块，即花括号包围的语句列表，下面两个同
[
else if (条件表达式)
    代码块
]...
[
else
    代码块
]
```
这里的“代码块”是用花括号括起来的语句列表，由于花括号是语法描述的格式之一，为避免误解用文字来描述

条件表达式的类型必须为`bool`

执行规则：
1. 遍历所有`if`和`else if`项，计算条件表达式，如某个条件表达式结果为true，则执行其下的代码块，执行完成后结束（即跳过本语句剩余的项）
1. 如果上一步中所有项的条件表达式计算结果都是false，若有`else`项，则执行`else`的代码块之后结束本语句执行，否则直接结束本语句的执行

## **return**

return语句用于从函数或方法中返回，根据返回类型定义有两种语法：
1. 若无返回类型，即返回类型为`void`，则语法是：`return;`
1. 若有返回类型，则语法是：`return 表达式;`，表达式类型必须和返回类型相同或者可以隐式转换为后者

注意，如果函数或方法的代码列表末尾没有指明return语句，则编译器会自动补一个，对于有返回类型的情形，自动补的return会返回其零值，
但正常编程的时候当然是推荐开发者明确写上return，不要依赖编译器的潜规则

## **defer**

### **语法**

defer语句用于注册当前函数或方法退出时的操作，有两种语法：
* defer后跟一个最后运算为函数或方法调用的表达式，语法：`defer 表达式;`
* defer后跟一个代码块，语法：`defer 代码块`，这里代码块是指花括号括起来的语句列表

defer并不立即执行它后面的表达式的调用或代码块的执行，而是将其注册，待到函数或方法退出（通过return语句正常退出，或抛异常的形式退出）时，
将按照defer注册顺序的**反序**依次触发执行

例：
```
public void main()
{
    defer println(1);   //defer1
    defer               //defer2
    {
        println(2);
    }
    println(3);
    //函数return，开始执行所有注册的defer，注意执行顺序和注册顺序相反
    //执行defer2
    //执行defer1
}

/*
输出：
3
2
1
*/
```

详细规则说明：

* 虽然defer代码的执行是在函数退出时触发，但是其后的表达式或代码块涉及的当前函数局部变量需要定义在defer之前，例如：
    ```
    public void main()
    {
        defer println(i);   //错误，i未定义
        int i;
    }
    ```
    这跟闭包的相关规定有一些类似，实际上`defer 代码块`的形式基本就等于是注册一个闭包对象，具体见下

* defer的两种形式除了单个表达式和多条语句的区别外，还有一些差别：

    1. 采用`defer 表达式;`的形式注册操作时，表达式需要是一个函数或方法调用，此时会立即对被调用的函数或方法本身求值，以及对参数列表求值，
    相当于生成一个相关值的“快照”，在触发执行的时候是用“快照”中的值进行一次调用操作

        例如：
        ```
        interface IntPrinter
        {
            void print(int i);
        }

        IntPrinter f()
        {
            println("calling f");
            return []{
                void print(int i)
                {
                    println(i);
                }
            };
        }

        public void main()
        {
            int i = 1;
            defer f().print(i);
            ++ i;
            println("i = %d".(i));
        }

        /*
        输出：
        calling f
        i = 2
        1
        */
        ```
        从这个例子可以看出，执行defer语句的时候，是立即计算了`f().print`和`i`的值，将它们注册到了defer的表中，
        然后在函数退出时取出来直接进行调用，因此虽然之后对`i`进行了自增操作，
        main函数结束的时候defer注册的表达式的执行还是打印出`i`在注册时的值`1`

    1. 采用`defer 代码块`形式注册操作时，相当于到触发的时候才执行代码块本身，引用的环境是触发时的

        例如：
        ```
        public void main()
        {
            int i = 1;
            defer
            {
                println(i);
            }
            ++ i;
            println("i = %d".(i));
        }

        /*
        输出：
        i = 2
        2
        */
        ```
        也可以这样理解，defer后跟的代码块实际是一个闭包函数，在触发时执行，例如上面的例子“基本等价”于下面的代码：
        ```
        public void main()
        {
            int i = 1;
            defer [-]{
                println(i);
            }.call();
            ++ i;
            println("i = %d".(i));
        }
        ```
        但是请注意，这只是在**绝大多数情况下等价，有例外情况**（否则可以取消`defer 代码块`的语法了），
        这个例外就是之前提到过的在defer操作中通过`catch<T>`捕获异常，由于Golang的语法规则以及Larva的实现原因，`catch<T>`若要正确执行，
        必须位于需要捕获异常的栈帧的下级调用栈帧中，但闭包和`usemethod`机制的调用可能有隐式的多级，
        因此设计了`defer 代码块`的语法来专门配合异常捕获机制，详细的说明在‘3.5.程序执行’的异常机制相关内容中

* defer注册的代码的触发边界是“函数或方法退出”，而不是函数中的代码块（所以最好不要用C++的局部变量销毁触发析构来理解）

    例如：
    ```
    public void main()
    {
        for (int i = 0; i < 3; ++ i)
        {
            defer println("defer1: %d".(i));
            defer
            {
                println("defer2: %d".(i));
            }
            println("i = %d".(i));
        }
        println("end");
    }

    /*
    输出：
    i = 0
    i = 1
    i = 2
    end
    defer2: 3
    defer1: 2
    defer2: 3
    defer1: 1
    defer2: 3
    defer1: 0
    */
    ```
    可以看到，在循环中执行defer语句，注册的操作是累积在当前函数的执行状态，退出时才触发
    
    *Note*：也可看到这里`defer2`和`defer1`输出的`i`不同，就是上面说的两种语法形式的区别

    注意：`defer 代码块`中的代码块是一个特殊的匿名函数，因此也算作defer触发边界，详细说明见下一条

* `defer 代码块`语法的代码块并不隶属于当前函数，而是一个隐式的闭包函数（但不是Larva层面的闭包，是在Golang层面的，如上所述其调用栈严格为一层），
这个代码块中有几点特殊的地方：

    * defer的代码块不能控制外部的流程：

        * 不能用return语句直接向函数或方法外部直接返回，因为defer注册的代码块被执行时已经是正在退出函数或方法了
        * 如果代码块在循环中，也不能通过break或continue语句转到循环外部，理由同上，此时已经是在退出中了

        当然了，defer代码块中的循环中还是能用break和continue的，其中的闭包代码中也能用return，这里说的是跳转不能跨越defer代码块边界

    * defer代码块边界等同函数边界，意即defer代码块的开始执行和结束执行对应着隐式的函数调用和函数退出

        例：
        ```
        public void main()
        {
            defer
            {
                defer println(1);
                println(2);
            }
            defer
            {
                defer println(3);
                println(4);
            }
            println(5);
        }

        /*
        输出：
        5
        4
        3
        2
        1
        */
        ```
        即每个defer代码块中的defer是在本代码块结束被触发，就像defer代码块是一个函数调用执行一样（可参考上面的`defer 闭包方法调用表达式;`来理解）

        defer代码块的执行中抛出的异常就和调用函数产生的异常一样，如果没有在某一层的defer中捕获，就会上抛到上一层栈帧，覆盖上一层栈帧的当前异常
        （如果有的话），详细机制可参考‘3.5.程序执行’中的异常一节
