# **表达式**

## **概述**

表达式是一个可以求值的语法单元，即“执行”其代码是一个求值的过程，执行后会得到一个结果，本文档描述的Larva语法层面的“表达式”是一个广义概念，
因此这里的“结果”分两种：
* “`void`值”，即表达式的执行是一个无返回类型，或者说返回类型为`void`的函数或方法的调用表达式，求值后可以说它没有结果，
也可抽象地说是一个`void`值结果
* 一个数据值，有确定的类型

注：和绝大多数语言一样，Larva支持多运算混合的复杂表达式，本文档中如无特殊说明，“xx运算的表达式”的说法是指“最后一步运算为xx运算的表达式”，
例如：`f(1 + 2).call(a.f() << b)`是一个“对`call`方法进行调用的表达式”，尽管其还有其他子表达式部分

为了方便描述语法，我们将Larva的表达式从形式上进行抽象，分为两大类：

1. 直接取值或取其运算分量含义的表达式，即没有做任何运算，本身就是一个运算分量，包括：

    * 名字，包括模块名、类名、函数名、变量名等，类方法中的`this`关键字也算在内
    * 各种字面量
    * 通过语法`[]{...}`构建的闭包对象

    *Note*：模块名、类名等本身不算做值，但是形式上算作运算分量

1. “运算符”加“运算分量”的形式，这个和AST的结构在形式上是统一的，这里的“运算分量”是一个抽象概念，并不仅仅是参与实际运算的值，例如：

    * `1+2`的运算符是`+`，运算分量是字面量`1`和`2`
    * `f(x, y)`的运算符是`()`（调用运算符，注意和括号的含义区别），运算分量是名字`f`和参数列表`x, y`
    * `new A(100, 200, 300)`的运算符是`new ()`，运算分量是类`A`和参数列表`100, 200, 300`
    * `a.f()`的运算符是`()`，运算分量是一个子表达式`a.f`和空的参数列表，子表达式的运算符是`.`，运算分量是名字`a`和`f`，
    注意子表达式这里可以是指“a模块的f函数”或“a对象的f方法”，从表达式语法分析的角度并不做具体的语义区分

    从这些例子中可看出，虽然Larva语法规定函数和类（还包括方法等）并不是一个有效的数据值，但它们也可看做是一个运算分量，
    而运算符表示运算的含义，即将若干运算分量放在一起进行某种“操作”而形成一个结果值，运算符可能并不是一个简单token，而是一个抽象的概念
    例如上面的运算符`new ()`的含义就是“通过构造方法创建对象实例”，根据`new`关键字的用法，
    也有对应的按属性赋值创建对象实例（`new {}`）和创建数组（`new []...`）等运算符概念，我们也可以将创建对象实例的操作笼统地称为`new`运算

## **语法**

本小节说明各种运算表达式的具体语法和运算规则

注：
* 对于数字类型的值进行运算可能产生溢出，关于溢出的规则在下面一小节中专门说明，本小节不做额外说明
* 若对于运算分量有类型要求，且运算分量为int字面量的，则适用‘3.4.变量和类型’中的隐式转换规则，相关内容也不做额外说明

### **强制类型转换**

Larva的强制类型转换用于将一个表达式的结果转为另一种类型，需要显式使用`cast`关键字

语法：`cast<目标类型>(表达式)`

例：`cast<double>(123L)`将`long`类型的字面量转换为`double`类型

类型强转规则：

1. 若符合隐式转换的规则，则也能使用强制转换，行为和隐式转换相同

    例：
    ```
    var a = cast<String>(nil);  //将nil字面量强制转换为String类型的nil值
    Any b = cast<Any>(123);
    ```

1. 不同数值类型之间可以进行强制转换，转换的行为和Go中数值类型的转换相同：
    1. 若为整数类型之间的转换，则原始值先做符号扩展，然后根据目标类型的位数进行末位截取
    1. 若为浮点数转为整数，则丢弃小数部分（向零取整）
    1. 若目标类型为浮点数，则转换后的数值根据目标类型的精度做必要的舍入
    1. 凡是涉及浮点数类型的转换，如果目标类型的值域范围内无法表示原始值，则转换会成功但是最终结果和平台相关

### **格式化字符串**

Larva在语法层面提供了格式化字符串功能，而不是像其他一些语言采用`printf`之类的函数的形式，这样设计在代码开发上比较简便，而且能做静态编译检查

语法：`格式串.(参数列表)`

* 格式串必须是一个字符串字面量，不能是其他表达式
* 参数列表类似函数或方法调用的参数列表语法，用逗号分隔，参数数量和各参数类型必须和格式串中指定的对应格式匹配，如果不匹配则编译报错，
显然地，参数不能有ref修饰

例：
```
"%d %d %s".(1, 2L, "hello")         //结果：“1 2 hello”
"[%-10s][%10s]".("hello", "world")  //结果：“[hello     ][     world]”
"%.2f%%".(0.123)                    //结果：“0.12%”
```

格式串的各种格式说明见下面的格式串的说明部分

*Note*：格式串规定为一个字符串字面量是为了能静态编译检查格式是否合法，不过我们仍然可以通过函数或方法的形式实现类似`printf`的函数，
在其中动态地分析格式即可，只是速度会比较慢，但需要注意，Larva并不支持可变参数列表，这时候的参数列表需要用数组等形式代替

#### **格式串语法说明**

格式串是一个字符串字面量，其中可用`%`符号开头的格式说明指定对应参数的出现位置以及用什么格式转换为格式化字符串

格式说明语法：`%[前缀][宽度][.精度]格式符`

前缀部分可包含字符`+`、`-`、`#`、`0`和空格符，可包含其中的多个，但不能有重复，具体含义：
* `+`：格式化数字的时候总是打印符号（意即非负数也输出一个正号）
* `-`：左对齐，根据宽度在右边补空格
* `#`：
    * 若使用非十进制格式格式化数字，则加上进制前缀
    * 若使用格式`eEfFgG`格式化浮点数，则总是带上小数点，并且在格式`g`或`G`时不省略末尾0
* `0`：右对齐时在左边补0，而不是补空格（对于数字，0是补在符号位和数字之间）
* 空格：格式化数字时，在左边留一个空格；以格式`x`或`X`格式化字符串时，对于输出的十六进制串用空格分隔每个字节（即两位HH）

宽度是一个十进制整数，指定了这个字段格式化后的宽度（按Unicode数量计算），若宽度比实际格式化结果长，
在没有指定前缀`-`、`0`或空格的情况下默认右对齐，左边补空格，否则按指定的前缀进行格式化；若宽度比实际格式化结果短，则按实际格式化结果输出

精度是一个十进制整数，只在某些格式下起作用：
* 如果是格式化一个浮点数，则精度根据具体格式而不同：
    * 对于`e`和`E`，是指科学计数法中小数点后的精确位数，例如`"%.2e".(12345.6789)`结果为`1.23e+04`
    * 对于`f`和`F`，是指小数点后的精确位数，例如`"%.2f".(12345.6789)`结果为`12345.68`（四舍五入了）
    * 对于`g`和`G`，是指有效数字位数，例如`"%.2g".(12345.6789)`结果为`1.2e+04`
    * 对于`x`和`X`，是指十六进制科学计数法中小数点后的精确位数，例如`"%.2x".(12345.6789)`结果为`0x1.82p+13`
    * 对于`b`不起作用
* 如果是格式化一个字符串，则精度表示截取的前多少个字符（按Unicode数量计算）
    * *Note*：按字符串格式进行格式化（格式`r`或`s`）时是先按宽度截取，然后将其作为结果去计算宽度的逻辑

格式说明：

|格式                                   |对应类型           |说明                                                           |
|---------------------------------------|-------------------|---------------------------------------------------------------|
|`t`                                    |`bool`             |`true`或`false`                                                |
|`b`                                    |数字               |对于整数类型，格式化为其二进制表示形式；对于浮点数参考详细说明 |
|`c`                                    |整数               |输出对应号码的Unicode字符，若超出范围则输出编号0xFFFD的字符    |
|`d`                                    |整数               |将整数格式化为十进制形式                                       |
|`o`                                    |整数               |将整数格式化为八进制形式                                       |
|`x`<br>`X`                             |数字、字符串       |参考详细说明                                                   |
|`e`<br>`E`<br>`f`<br>`F`<br>`g`<br>`G` |浮点数             |参考详细说明                                                   |
|`r`<br>`s`                             |任意               |参考详细说明                                                   |
|`T`                                    |任意               |输出对应参数对象的类型，参考详细说明                           |
|`%`                                    |无                 |符号`%`本身，注意：不能应用任何前缀格式说明、宽度或精度说明    |

详细说明：
1. 用格式`b`格式化浮点数会得到一个十进制整数+二进制指数的形式，例如`12345p-4`，相当于“12345×2<sup>-4</sup>”，不过一般来说，
这个格式会将浮点数的尾数部分作为一个大整数，然后将浮点数的指数部分原样表示出来，因此`12345p-4`实际格式化后的结果会是`6786735522447360p-43`，
形式不同但是值一样
1. 格式`x`和`X`控制十六进制格式化，其大小写的区别是控制输出的十六进制的`a-f`的大小写，其余相同
    * 匹配数字类型时，输出其十六进制表示形式，具体形式可参考‘3.2.词法元素’中的整数和浮点数字面量的十六进制形式的说明，
    注意浮点数格式化后会自动有`0x`或`0X`前缀
    * 匹配字符串时，输出其十六进制串，可用前缀格式控制是否空格分隔，例如`"%x:% X".("LMN", "OPQ")`输出`4c4d4e:4F 50 51`

1. `eEfFgG`这六个格式都是控制浮点数格式化的：
    * `e`和`E`表示按科学计数法（即十进制，以10为底）格式化，其大小写控制输出的指数部分标识是`e`还是`E`
    * `f`和`F`表示按正常十进制小数形式格式化，二者等价
    * `g`和`G`表示智能判断，如果数字位数比较小则按格式`f`格式化，否则按格式`e`或`E`格式化

1. `r`和`s`格式都可匹配任意类型的参数，并根据参数具体的值输出其字符串表示形式
    * 对于接口的nil值，输出`<nil>`
    * 对于`bool`值，输出`true`或`false`，即用格式`t`
    * 对于整数值，用格式`d`
    * 对于浮点数值，用格式`g`
    * 对于其他类型的参数值：
        * 若格式是`s`并且参数对象实现了`__builtins.Stringable`接口，则调用其`str`方法并输出返回的字符串，否则按格式`r`处理
        * 若格式是`r`或格式为`s`但参数对象没有实现`__builtins.Stringable`接口，则根据参数的具体对象值来决定行为：
            * 若参数对象是某类的nil值，且实现了`__builtins.NilRepresentable`接口，则调用其`nil_repr`方法并输出返回的字符串
            * 若参数对象是某类的对象，且实现了`__builtins.Representable`接口，则调用其`repr`方法并输出返回的字符串
            * 若没有实现对应的接口：
                * 若参数是Larva对象，则输出`<类型 object at 0x地址>`
                * 若参数不是Larva对象，则输出`<GoType GO类型 object>`

    总之，`r`和`s`对于任何输入都会有相关逻辑，“尽量”去输出一个结果而不会出现错误（除非用户自己实现的`str`等方法中有异常）

1. 格式`T`用于输出参数值的类型
    * 对于接口的nil值，输出`<nil>`
    * 对于Larva的合法对象，输出其对应的类型名字（带模块号的全名）
    * 对于Go层面的数据，输出`<GoType 类型名>`

    注意这个格式输出的是参数的实际值的类型，而非参数表达式的类型，例如`"%T".(cast<Any>(123))`会输出`int`而不是`Any`，
    事实上不可能直接用格式`T`输出任何接口的名字，因为接口值要么是nil，要么是非接口类型的值

*Note*：格式串解析是语法分析阶段，因此词法阶段用其他形式表示`%`并不影响结果，如`"\x25s".(123)`

### **new运算**

Larva中可通过`new`关键字来创建类的对象实例或数组，创建语法本身也是一个表达式

#### **创建类对象实例**

创建类的对象实例的语法说明参考‘3.11.类’，这里不再重复

#### **创建数组**

创建数组有两种语法形式

1. 通过指定大小创建

    对于N维数组，new的时候可以通过指定前1~N维的大小来创建，语法是`new`关键字后跟数组类型，然后在类型的前若干维的方括号中直接写各维度的大小
    * 至少指定第一维度的大小
    * 指定的多个维度的大小必须从第一个方括号开始连续写在各方括号中
    * 执行的时候会按维度依次创建各层指定了大小的数组
    * 若某一维度的数组在创建时，已经是最后一维，或者之后维度的子数组没有指定大小，则创建的数组的元素值为零值（意即如果是子数组，则为nil）
    * 维度大小可以是`ulong`之外的任意整数类型，值必须非负，如果出现负数则new的过程会抛出异常
        * *Note*：和下标运算不一样，创建数组时的大小不能是`ulong`；另外Larva允许大小为0的数组

    *Note*：在‘3.4.变量和类型’中，已经讲过了多维数组实际是元素为数组的数组，可参考相关内容

    例：
    ```
    new int[10]         //int[]类型，含10个int元素，都是0
    new String[3][4]    //String[][]类型，有3×4个元素，都是String类的nil
    new Any[2][5][][]   //Any[][][][]类型，前两维是2×5个元素，都是Any[][]类型的nil
    new double[0]       //double[]类型，有0个元素，注意0个元素的数组是合法的，和数组类型的nil值是不同的概念
    ```

1. 通过初始化元素值创建

    数组也可以通过初始化元素来创建，语法规则：
    * `new`关键字后直接跟数组类型，后跟用花括号括起来的表达式列表，用于指定第一维度的各元素，按惯例支持最后一项的逗号

        * 例：`new int[]{1, 2, 3}`，相当于`new int[3]`之后再给数组各元素赋值为对应值

    * 如果数组类型是`__builtins.Pair<F, S>[]`，则可以用冒号分隔的两个元素映射的方式来写

        例如：
        ```
        var a = new Pair<int, String>[]{
            1: "hello",
            2: "world",
        };
        ```
        其中每个表达式对的对应元素只要能隐式转换为`Pair`泛型的两个类型即可

    * 支持多维数组的嵌套赋值，表达式列表中对于子数组可以省略`new`，直接用花括号指定，对于`Pair`的嵌套情况也是一样的；子数组当然也可以是nil

        例如：
        ```
        var a = new Pair<double, Pair<long[], String>[]>[][]{
            {
                1.0:    {
                    {1L, 2L, 3L}:   "abc",
                    {}:             nil,
                },
                2.0:    nil,
            },      //第一个Pair<double, Pair<long[], String>>[]

            nil,    //第二个，为nil

            {
            },      //第三个，大小为0的数组
        };
        ```
        需要注意只有`Pair`的数组才能用这种冒号分隔的`{first: second, ...}`列表形式，对于`Pair`自己还是得使用`make_pair`

        另外也不要和按属性初始化混用，例如：
        ```
        class A
        {
            int x;
        }

        var a = new A[]{
            {x: 1}, //错误，这里还是得老老实实写new A{x: 1}
        };
        ```

    *Note*：Larva一开始没有将map之类的数据结构做成内建的，而是放在了`util`模块，引入`Pair`类型和针对其数组的初始化语法是为了开发方便而后面加的，
    看上去不如Go的map直接列表赋值方便，但由于Larva的`util.HashMap`等数据结构是一个类，
    如果后期设计一个`new util.HashMap<K, V>{}`语法又跟类的按属性初始化创建语法冲突了，所以如果要在代码中写一个HashMap的初始化，可能就比较纠结：
    ```
    //的确啰嗦了点，但要像Go那样把HashMap内置化又会有其他一些麻烦，设计和实现方面的改动太大
    var m = new util.HashMap<int, String>(new Pair<int, String>[]{
        1: "hello",
        2: "world",
    }.iter());
    ```

### **后缀运算**

后缀运算可看做是一类双目运算，但其在形式上和普通的双目运算不同，两个运算分量的位置不是对等的

#### **取属性或方法**

语法：`对象表达式.属性或方法名`，即`.`运算符，用于对一个计算出的对象取其属性或方法
* 对象表达式的结果类型必须是接口值或对象实例
    * 如果属性或方法名不存在，则编译报错
    * 如果对象表达式为接口或类的nil值，则可能运行时崩溃，参考‘3.4.变量和类型’中的相关内容
* 如果是取到属性，则此表达式是一个左值，其值为属性的值
* 如果是取到方法，则此表达式并不作为一个完整表达式（因为不支持对方法本身直接“求值”），后面必须再跟调用运算符

#### **调用运算**

语法：`函数或方法表达式(参数列表)`，即`()`运算符，用于对一个函数或方法表达式做调用运算
* 显然地，在Larva语法规定下，函数或方法表达式只能是函数名（包括`模块名.函数名`这种形式）或取对象方法的表达式
* 参数列表在表达式概念上作为一个独立的运算分量，其本身是可以包含任意多个表达式的列表，可以带`ref`修饰
* 具体的调用运算规则可参考‘3.10.函数’一节

#### **下标和切片**

下标和切片运算，即`[]`和`[:]`两个运算符，是数组专有的运算，其语法和运算规则请参考‘3.4.变量和类型’的数组说明部分，这里不再重复

### **算术运算**

算术运算用于对数字类型（即除`bool`之外的其他基础类型）做运算

#### **正负运算**

正负运算是前缀单目运算，语法：`{+ ¦ -}运算分量表达式`
* 运算分量表达式结果必须是一个数字类型
* 正负运算表达式的结果类型和运算分量表达式类型相同，值为其结果取正或取负数

#### **加减乘除和取模运算**

这五种运算的含义就是普通的算术含义，语法：`运算分量表达式A {+ ¦ - ¦ * ¦ / ¦ %} 运算分量表达式B`
* 运算分量表达式A和B必须是数字类型，并且类型相同
* 运算结果为对应算术运算的结果，类型和两个运算分量表达式的类型相同
* 若为整数除法或取模运算，除数不能为0，否则运行时崩溃
* 支持浮点数直接取模运算，规则和Go的`math.Mod`相同
* 整数类型的除法和取模运算按照**商向零取整**的规则

### **位运算**

位运算是针对整数类型的位（bit）的一系列运算

#### **按位取反**

按位取反是一个前缀单目运算，语法：`~运算分量表达式`
* 运算分量表达式必须为整数类型
* 运算结果为运算分量表达式的值的各位取反（1变0、0变1），结果类型和运算分量表达式类型相同

#### **按位与、或、异或**

可对两个整数类型的值进行按位的与（`&`）、或（`|`）、异或（`^`）三种运算，语法：`运算分量表达式A {& ¦ | ¦ ^} 运算分量表达式B`
* 运算分量表达式A和B必须是整数类型，并且类型相同
* 运算结果为两个运算分量的对应位进行指定运算的结果，类型和两个运算分量表达式的类型相同，规则：
    * 与运算`&`：当两个bit为`1`时，结果为`1`，否则结果为`0`
    * 或运算`|`：当两个bit为`0`时，结果为`0`，否则结果为`1`
    * 异或运算`^`：当两个bit不同时，结果为`1`，否则结果为`0`

#### **移位运算**

可对一个整数类型的值进行左移`<<`或右移`>>`运算，语法：`运算分量表达式A {<< ¦ >>} 运算分量表达式B`
* 运算分量表达式A必须是一个整数类型，运算分量表达式B必须是一个**无符号整数**类型
* 对于运算分量表达式A来说，左移一位等同于乘以2，右移一位等同于除以2后向负无穷取整
* 不限制移位数量，移位n位等同于移位一位的操作重复n次

### **比较运算**

比较运算用于对各种数据进行判同、判等、比大小等运算操作，都是双目运算，且计算结果都是`bool`类型

#### **比大小运算**

可使用四种运算符比较数字类型的值的大小关系：
* `<`：小于
* `<=`：小于等于
* `>`：大于
* `>=`：大于等于

语法：`运算分量表达式A {< ¦ <= ¦ > ¦ >=} 运算分量表达式B`
* 运算分量表达式A和B必须是数字类型，并且类型相同
* 对于浮点数类型的`Inf`、`Nan`等特殊值参与的比大小运算，遵循浮点数相关的规则

#### **判等运算**

判等运算用`==`和`!=`两个运算符判定两个基础类型的值相等或不相等，对同样的运算分量，两个运算的结果相反，即`A!=B`等同于`!(A==B)`

语法：`运算分量表达式A {== ¦ !=} 运算分量表达式B`
* 运算分量表达式A和B必须是基础类型，并且类型相同
    * *Note*：基础类型包括数字类型和`bool`，即`bool`类型也可判等

#### **判同运算**

判同运算用`===`和`!==`两个运算符判定两个接口是否引用同一个对象，或两个对象实例是否为同一个，`A!==B`等同于`!(A===B)`

语法：`运算分量表达式A {=== ¦ !==} 运算分量表达式B`
* 运算分量表达式A和B必须是类或接口类型，类型必须相同（允许隐式转换）
    * 若两个运算分量类型是类，则比较两个表达式结果是否引用同一个对象
    * 若两个运算分量类型是接口，则分情况：
        * 若两个接口都引用了类的对象实例，则在为同一个对象的时候认为相同（即`===`结果为`true`），否则不同
        * 若为两个`Any`接口，且引用的是基础类型的值，则在两个引用的值的类型相同且值相同时认为相同，否则不同
        * 其余情况，计算结果都是两个结果不同

*Note*：简单点的理解，也可认为对于基础类型（值类型），值相同即看做是同一个对象

### **逻辑运算**

逻辑运算是针对`bool`类型的一系列运算，运算分量和运算结果都是`bool`类型的值

1. 逻辑非运算

    语法：`!表达式`，对表达式的结果做逻辑非运算，即如果表达式结果为`true`，则计算出`false`，反之亦然

1. 逻辑与和逻辑或运算

    语法：`表达式A {&& ¦ ||} 表达式B`
    * 这两种运算都规定了求值顺序（求值顺序的详细说明见下面小节），并且使用短路规则，即先计算表达式A的值，然后根据情况决定是否计算表达式B的值
    * 对于逻辑与运算`&&`，若表达式A结果为`true`，则计算表达式B的值，并将其作为`&&`表达式的计算结果；若表达式A的结果为`false`，则不计算表达式B，
    立即求得`&&`表达式的结果为`false`
    * 对于逻辑或运算`||`，若表达式A结果为`false`，则计算表达式B的值，并将其作为`||`表达式的计算结果；若表达式A的结果为`true`，则不计算表达式B，
    立即求得`||`表达式的结果为`true`

    *Note*：以上是形式化的规则描述，也可简单理解为`&&`是二者都是`true`时整个表达式结果才为`true`，否则`false`，
    因此当左边的表达式A结果为`false`的时候，就可省去右边表达式B的求值过程了，`||`运算的规则亦可用类似的方式理解

### **if-else表达式**

`if-else`表达式是一个三目运算符，用于根据条件计算不同的表达式

语法：`表达式A if 条件表达式 else 表达式B`
* 条件表达式的类型需要是`bool`
* 计算`if-else`表达式时，先计算条件表达式，如为`true`，则计算表达式A，否则计算表达式B，`if-else`表达式的计算结果就是被选择的表达式A或B的计算结果
* 表达式A和B的类型必须相同，`if-else`表达式的结果类型就是表达式A或B的类型
    * 表达式A或B可以是int字面量和另一个数字类型，只要int字面量根据规则可以隐式转换为另一个类型即可；如果二者都是int字面量类型，则视为int类型
    * 除int字面量的特殊处理外，即便表达式A和B某一个可以隐式转换为另一个，也作为语法错误处理，需要在代码中显式保证二者类型完全一致，
    这主要也是为了可读性（因为`if-else`表达式往往比较长）

`if-else`运算在结合性方面有特殊规定，具体见下面‘优先级和结合性’小节的相关内容

*Note*
* 这个运算符是借用了Python的语法，而不是使用C++和Java的`?:`，虽然我个人认为后者更好看一些，但由于Larva中的冒号符`:`已经有一些地方在用了，
如切片、Pair数组的元素初始化语法等，如果混写可能导致可读性问题，所以改用了`if-else`的方式
* Go并不直接支持这种三目运算符，在编译输出目标代码的时候，`if-else`表达式是用Go的闭包来做的，这可能导致一些性能上的问题，不过应该不严重，
Larva的设计理念还是更倾向于简化开发

## **数值运算的溢出**

整数和浮点数的计算有可能产生溢出，Larva在溢出方面的规定直接采用Go的规定，简述如下：

* 无符号整数的运算结果是其算术结果对2<sup>n</sup>取模，其中n是运算分量的bit数，意即结果截取最后n位
* 有符号整数的运算结果如果出现溢出，并不会导致运行时崩溃，而是会给出一个合法的溢出后的转换结果，其结果是确定的，
编译器并不会假设代码不会出现运算溢出（即不会做相关优化）
* 浮点数运算溢出的处理原则遵循浮点数和平台的规范

## **优先级和结合性**

如果一个表达式包含了相邻的并列的运算并且没有用括号指定优先级（括号的说明见下面的小节），那么运算的先后顺序就会根据优先级和结合性来决定，规则：
* 优先级高的运算
* 同优先级的按结合性选择自左至右或自右至左进行计算

Larva的优先级设计基本和C++、Java保持一致，下表是按优先级从高到低对运算进行排列说明，并说明每个优先级的运算指定结合性：

|运算               |结合性     |备注                                                       |
|-------------------|-----------|-----------------------------------------------------------|
|`new`              |无         |`new`运算，各个`new`之间不可能并列，无结合性的意义         |
|`[] [:] . ()`      |自左至右   |后缀运算，`.`是取属性或方法的运算，`()`是调用运算          |
|`~ ! + -`          |自右至左   |前缀单目运算，这里的`+ -`是指正负运算                      |
|`* / %`            |自左至右   |算术乘除和取模运算                                         |
|`+ -`              |自左至右   |算术加减运算                                               |
|`<< >>`            |自左至右   |移位运算                                                   |
|`< <= > >=`        |自左至右   |比较大小运算                                               |
|`=== !== == !=`    |自左至右   |判同和判等运算                                             |
|`&`                |自左至右   |按位与                                                     |
|`^`                |自左至右   |按位异或                                                   |
|`\|`               |自左至右   |按位或                                                     |
|`&&`               |自左至右   |逻辑与                                                     |
|`\|\|`             |自左至右   |逻辑或                                                     |
|`if-else`          |无         |三目运算符，在结合性方面有特殊规定，见下一小节的详细说明   |

详细说明：
* 请注意“先计算优先级高的运算”是指**相邻并列**的两个运算，而不是整个表达式，例如`a+b-c*d`中，优先级的体现仅在于`*`和`-`两个运算中先算`c*d`，
而前面的`+`和`*`并不相邻，因此`+`只和`-`进行判断比较，二者优先级相同，按结合性是`+`先计算，所以这个式子的计算流程是先计算`a+b`和`c*d`，
然后做`-`，而`-`两边的这两者谁先谁后则没有明确规定，这属于求值顺序的范畴，和优先级无关
* 强制类型转换运算`cast`虽然是一个特殊语法，但在优先级和结合性规则中可看做是一个函数调用的形式
* 格式化字符串的“运算”`.()`虽然是一个特殊语法，但在这里可视为一个省略方法名的方法调用形式（`.format()`这种的简写语法），因此属于后缀运算

*Note*：如果打开本文档源代码，就会发现上面的表格中的`|`和`||`两个运算符中采用了转义符，是因为github的Markdown解析器需要这样做，
否则会将竖线作为表格分隔符，然而在某些Markdown工具下反引号`` ` ``括起来的内容作为一个整体，所以又会将反斜杠显示出来，
这里暂时采用兼容github的写法

### **括号的使用**

在表达式中可以用圆括号`()`改变运算的优先级，括号括起来的作为一个整体的子表达式，例如`(1+2)*3`会先计算括号中的`1+2`和`3`，然后再做乘法，
这和算术中使用括号的方法和含义是一样的

若表达式的运算分量之间，或和运算符在语法上有一些冲突或二义性的时候，也需要用括号来分隔，否则可能出现非预期的效果或错误，
例如创建一个数组并立即取其分片，需要写成`(new int[a])[b : c]`的形式，如果去掉了圆括号，则会被解析为创建二维数组，进而会在分片语法的`:`处报错，
对于多维数组即便是写`new int[d][][e : f]`这种形式也是错误的，因为如果多维数组后面的维度为空，则需要都是空内容的方括号组合，会在`e`处报错，
尽管从人的思考角度可能认为这里没有歧义，但是Larva编译器的分析过程比较机械，因此还是需要写成`(new int[d][])[e : f]`

* *Note*：回忆一下词法分析文档中举过的`1.a()`这个例子，词法分析器会将第一个token解析为`1.`，即一个浮点数字面量，而不是看做对`1`执行方法`a()`，
和这里的问题有相似之处，Larva采用比较机械的语法分析规则是为了实现和理解上的直白简单，而不会引入太多的“智能”识别，这也是减少灵活性，
避免引起更多问题

上面的优先级和结合性表中，对于三目运算符`if-else`的结合性的描述是“无”，这是因为三目运算符如果多个并列连写，很容易造成可读性问题，
因此Larva特别规定了三目运算符多个并列连写的时候一定要加括号进行区分，
例如`a if b if c else d else e`或`a if b else c if d else e`的写法都是非法的，尽管在具体的结合性规则下它们也都有确定含义，
但对读代码的人是个挑战，因此前者必须写成`a if (b if c else d) else e`，
而后者则需要根据实际需求写成`(a if b else c) if d else e`或者`a if b else (c if d else e)`

有些运算符或运算符的某部分本身就是括号或分隔符`:`和`,`，例如`[]`、`[:]`、`()`以及`new ()`、`new {}`等，
这种括号内部的一个或多个表达式是作为子表达式看待，而不是和外层的括号运算符构成并列关系，例如`a[b+c].d`中，`[]`和`.`是并列关系，
而`+`是被`[]`包含的子表达式运算，和后者不是并列关系，因此没有优先级先后的问题

## **求值顺序和副作用**

一个表达式可能有多个子表达式，例如双目运算符的两个运算分量，函数或方法调用的运算中的各参数等，由于做运算需要将各运算分量的值先计算出来，
因此就涉及到一个求值顺序的问题，具体地可以说是一个表达式中各子表达式的计算顺序

Larva并没有严格规定所有运算的求值顺序，有明确规定的只有两类：
1. `&&`和`||`两个逻辑运算符，会先计算左运算分量，然后根据计算的结果来决定是否计算右运算分量
1. `if-else`运算，会先计算条件表达式，根据计算结果决定计算其他两个运算分量中的某一个

对于其他运算，Larva并不规定运算分量中子表达式的求值顺序，例如`f() + g()`，加法的两个运算分量谁先执行是不一定的，
如果开发者需要`f()`比`g()`先执行，可以用变量保存其执行结果再相加，利用语句执行的顺序性来保证两个函数的执行顺序

实际上如果各运算分量之间的计算是各自独立的，不会相互影响，那么求值顺序的改变不会影响到计算结果，但是Larva中的表达式不仅是普通运算求值，
还包含函数和方法调用，而函数和方法调用有可能会产生副作用，包括但不限于修改全局数据（全局变量或堆内存等）、进行IO操作等，
这就可能使不同运算分量的求值（函数或方法的调用执行）之间产生互相影响，例如：
```
int a = 1;

int f()
{
    ++ a;
    return a;
}

public void main()
{
    /*
    如果求值顺序是a、f()，那么结果是1+2=3
    如果求值顺序是f()、a，那么结果是2+2=4
    */
    println(a + f());
}
```
如示例的注释所说，由于两个运算分量都存取了全局变量`a`，则由于不保证求值顺序，结果是不定的，应该避免写出这种代码，如果一定要写，
也应引入临时变量来手动设置执行顺序：
```
public void main()
{
    /*
    如果要求求值顺序是a、f()
    */
    int tmp_a = a;
    int tmp_f_result = f();
    println(tmp_a + tmp_f_result);
}
```

*Note*：
* 赋值语句（包括自增自减）在Larva中是语句而非表达式，因此没有C++、Java等语言中的副作用问题
* Golang在语言标准上是规定了部分求值顺序的，例如一个语句或表达式中的函数或方法调用是从左到右，由于大部分时候Larva代码是直译为Golang代码，
因此也会有类似的行为，不过Larva依然没有将其定死，一方面是我认为复杂的表达式即便有良好的顺序定义，可读性也比较差，
另一方面是为Larva本身的优化留一些空间
