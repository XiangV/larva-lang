# **表达式**

## **概述**

表达式是一个可以求值的语法单元，即“执行”其代码是一个求值的过程，执行后会得到一个结果，本文档描述的Larva语法层面的“表达式”是一个广义概念，
因此这里的“结果”分两种：
* “`void`值”，即表达式的执行是一个无返回类型，或者说返回类型为`void`的函数或方法的调用表达式，求值后可以说它没有结果，
也可抽象地说是一个`void`值结果
* 一个数据值，有确定的类型

注：和绝大多数语言一样，Larva支持多运算混合的复杂表达式，本文档中如无特殊说明，“xx运算的表达式”的说法是指“最后一步运算为xx运算的表达式”，
例如：`f(1 + 2).call(a.f() << b)`是一个“对`call`方法进行调用的表达式”，尽管其还有其他子表达式部分

为了方便描述语法，我们将Larva的表达式从形式上进行抽象，分为两大类：

1. 直接取值或取其运算分量含义的表达式，即没有做任何运算，本身就是一个运算分量，包括：

    * 名字，包括模块名、类名、函数名、变量名等，类方法中的`this`关键字也算在内
    * 各种字面量
    * 通过语法`[]{...}`构建的闭包对象

    *Note*：模块名、类名等本身不算做值，但是形式上算作运算分量

1. “运算符”加“运算分量”的形式，这个和AST的结构在形式上是统一的，这里的“运算分量”是一个抽象概念，并不仅仅是参与实际运算的值，例如：

    * `1+2`的运算符是`+`，运算分量是字面量`1`和`2`
    * `f(x, y)`的运算符是`()`（调用运算符，注意和括号的含义区别），运算分量是名字`f`和参数列表`x, y`
    * `new A(100, 200, 300)`的运算符是`new ()`，运算分量是类`A`和参数列表`100, 200, 300`
    * `a.f()`的运算符是`()`，运算分量是一个子表达式`a.f`和空的参数列表，子表达式的运算符是`.`，运算分量是名字`a`和`f`，
    注意子表达式这里可以是指“a模块的f函数”或“a对象的f方法”，从表达式语法分析的角度并不做具体的语义区分

    从这些例子中可看出，虽然Larva语法规定函数和类（还包括方法等）并不是一个有效的数据值，但它们也可看做是一个运算分量，
    而运算符表示运算的含义，即将若干运算分量放在一起进行某种“操作”而形成一个结果值，运算符可能并不是一个简单token，而是一个抽象的概念
    例如上面的运算符`new ()`的含义就是“通过构造方法创建对象实例”，根据`new`关键字的用法，
    也有对应的按属性赋值创建对象实例（`new {}`）和创建数组（`new []...`）等运算符概念，我们也可以将创建对象实例的操作笼统地称为`new`运算

## **语法**

本小节说明各种运算表达式的具体语法和运算规则

### **强制类型转换**

Larva的强制类型转换用于将一个表达式的结果转为另一种类型，需要显式使用`cast`关键字

语法：`cast<目标类型>(表达式)`

例：`cast<double>(123L)`将`long`类型的字面量转换为`double`类型

类型强转规则：

1. 若符合隐式转换的规则，则也能使用强制转换，行为和隐式转换相同

    例：
    ```
    var a = cast<String>(nil);  //将nil字面量强制转换为String类型的nil值
    Any b = cast<Any>(123);
    ```

1. 不同数值类型之间可以进行强制转换，转换的行为和Go中数值类型的转换相同：
    1. 若为整数类型之间的转换，则原始值先做符号扩展，然后根据目标类型的位数进行末位截取
    1. 若为浮点数转为整数，则丢弃小数部分（向零取整）
    1. 若目标类型为浮点数，则转换后的数值根据目标类型的精度做必要的舍入
    1. 凡是涉及浮点数类型的转换，如果目标类型的值域范围内无法表示原始值，则转换会成功但是最终结果和平台相关

### **格式化字符串**

Larva在语法层面提供了格式化字符串功能，而不是像其他一些语言采用`printf`之类的函数的形式，这样设计在代码开发上比较简便，而且能做静态编译检查

语法：`格式串.(参数列表)`

* 格式串必须是一个字符串字面量，不能是其他表达式
* 参数列表类似函数或方法调用的参数列表语法，用逗号分隔，参数数量和各参数类型必须和格式串中指定的对应格式匹配，如果不匹配则编译报错，
显然地，参数不能有ref修饰

例：
```
"%d %d %s".(1, 2L, "hello")         //结果：“1 2 hello”
"[%-10s][%10s]".("hello", "world")  //结果：“[hello     ][     world]”
"%.2f%%".(0.123)                    //结果：“0.12%”
```

格式串的各种格式说明见下面的格式串的说明部分

*Note*：格式串规定为一个字符串字面量是为了能静态编译检查格式是否合法，不过我们仍然可以通过函数或方法的形式实现类似`printf`的函数，
在其中动态地分析格式即可，只是速度会比较慢，但需要注意，Larva并不支持可变参数列表，这时候的参数列表需要用数组等形式代替

#### **格式串语法说明**

格式串是一个字符串字面量，其中可用`%`符号开头的格式说明指定对应参数的出现位置以及用什么格式转换为格式化字符串

格式说明语法：`%[前缀][宽度][.精度]格式符`

前缀部分可包含字符`+`、`-`、`#`、`0`和空格符，可包含其中的多个，但不能有重复，具体含义：
* `+`：格式化数字的时候总是打印符号（意即非负数也输出一个正号）
* `-`：左对齐，根据宽度在右边补空格
* `#`：
    * 若使用非十进制格式格式化数字，则加上进制前缀
    * 若使用格式`eEfFgG`格式化浮点数，则总是带上小数点，并且在格式`g`或`G`时不省略末尾0
* `0`：右对齐时在左边补0，而不是补空格（对于数字，0是补在符号位和数字之间）
* 空格：格式化数字时，在左边留一个空格；以格式`x`或`X`格式化字符串时，对于输出的十六进制串用空格分隔每个字节（即两位HH）

宽度是一个十进制整数，指定了这个字段格式化后的宽度（按Unicode数量计算），若宽度比实际格式化结果长，
在没有指定前缀`-`、`0`或空格的情况下默认右对齐，左边补空格，否则按指定的前缀进行格式化；若宽度比实际格式化结果短，则按实际格式化结果输出

精度是一个十进制整数，只在某些格式下起作用：
* 如果是格式化一个浮点数，则精度根据具体格式而不同：
    * 对于`e`和`E`，是指科学计数法中小数点后的精确位数，例如`"%.2e".(12345.6789)`结果为`1.23e+04`
    * 对于`f`和`F`，是指小数点后的精确位数，例如`"%.2f".(12345.6789)`结果为`12345.68`（四舍五入了）
    * 对于`g`和`G`，是指有效数字位数，例如`"%.2g".(12345.6789)`结果为`1.2e+04`
    * 对于`x`和`X`，是指十六进制科学计数法中小数点后的精确位数，例如`"%.2x".(12345.6789)`结果为`0x1.82p+13`
    * 对于`b`不起作用
* 如果是格式化一个字符串，则精度表示截取的前多少个字符（按Unicode数量计算）
    * *Note*：按字符串格式进行格式化（格式`r`或`s`）时是先按宽度截取，然后将其作为结果去计算宽度的逻辑

格式说明：
|格式                                   |对应类型           |说明                                                           |
|---------------------------------------|-------------------|---------------------------------------------------------------|
|`t`                                    |`bool`             |`true`或`false`                                                |
|`b`                                    |数字               |对于整数类型，格式化为其二进制表示形式；对于浮点数参考详细说明 |
|`c`                                    |整数               |输出对应号码的Unicode字符，若超出范围则输出编号0xFFFD的字符    |
|`d`                                    |整数               |将整数格式化为十进制形式                                       |
|`o`                                    |整数               |将整数格式化为八进制形式                                       |
|`x`<br>`X`                             |数字、字符串       |参考详细说明                                                   |
|`e`<br>`E`<br>`f`<br>`F`<br>`g`<br>`G` |浮点数             |参考详细说明                                                   |
|`r`<br>`s`                             |任意               |参考详细说明                                                   |
|`T`                                    |任意               |输出对应参数对象的类型，参考详细说明                           |
|`%`                                    |无                 |符号`%`本身，注意：不能应用任何前缀格式说明、宽度或精度说明    |

详细说明：
1. 用格式`b`格式化浮点数会得到一个十进制整数+二进制指数的形式，例如`12345p-4`，相当于“12345×2<sup>-4</sup>”，不过一般来说，
这个格式会将浮点数的尾数部分作为一个大整数，然后将浮点数的指数部分原样表示出来，因此`12345p-4`实际格式化后的结果会是`6786735522447360p-43`，
形式不同但是值一样
1. 格式`x`和`X`控制十六进制格式化，其大小写控制输出的十六进制的`a-f`的大小写，其余相同
    * 匹配数字类型时，输出其十六进制表示形式，具体形式可参考‘3.2.词法元素’中的整数和浮点数字面量的十六进制形式的说明，
    注意浮点数格式化后会自动有`0x`或`0X`前缀
    * 匹配字符串时，输出其十六进制串，可用前缀格式控制是否空格分隔，例如`"%x:% X".("abc", "OPQ")`输出`616263:4F 50 51`

1. `eEfFgG`这六个格式都是控制浮点数格式化的：
    * `e`和`E`表示按科学计数法（即十进制，以10为底）格式化，其大小写控制输出的指数部分标识是`e`还是`E`
    * `f`和`F`表示按正常十进制小数形式格式化，二者等价
    * `g`和`G`表示智能判断，如果数字位数比较小则按格式`f`格式化，否则按格式`e`或`E`格式化

1. `r`和`s`格式都可匹配任意类型的参数，并根据参数具体的值输出其字符串表示形式
    * 对于接口的nil值，输出`<nil>`
    * 对于`bool`值，输出`true`或`false`，即用格式`t`
    * 对于整数值，用格式`d`
    * 对于浮点数值，用格式`g`
    * 对于其他类型的参数值：
        * 若格式是`s`并且参数对象实现了`__builtins.Stringable`接口，则调用其`str`方法并输出返回的字符串，否则按格式`r`处理
        * 若格式是`r`，则根据参数的具体对象值来决定行为：
            * 若参数对象是某类的nil值，且实现了`__builtins.NilRepresentable`接口，则调用其`nil_repr`方法并输出返回的字符串
            * 若参数对象是某类的对象，且实现了`__builtins.Representable`接口，则调用其`repr`方法并输出返回的字符串
            * 若没有实现对应的接口：
                * 若参数是Larva对象，则输出`<类型 object at 0x地址>`
                * 若参数不是Larva对象，则输出`<GoType GO类型 object>`

    总之，`r`和`s`对于任何输入都会有相关逻辑，“尽量”去输出一个结果而不会出现错误（除非用户自己实现的`str`等方法中有异常）

1. 格式`T`用于输出参数值的类型
    * 对于接口的nil值，输出`<nil>`
    * 对于Larva的合法对象，输出其对应的类型名字（带模块号的全名）
    * 对于Go层面的数据，输出`<GoType 类型名>`

    注意这个格式输出的是参数的实际值的类型，而非参数表达式的类型，例如`"%T".(cast<Any>(123))`会输出`int`而不是`Any`，
    事实上不可能直接用格式`T`输出任何接口的名字，因为接口值要么是nil，要么是非接口类型的值

*Note*：格式串解析是语法分析阶段，因此词法阶段用其他形式表示`%`并不影响结果，如`"\x25s".(123)`

### **new运算**

todo

### **后缀运算**

todo

### **前缀单目运算**

todo

### **算术运算**

todo

### **位运算**

todo

### **比较运算**

todo

### **逻辑运算**

todo

### **if-else表达式**

todo

## **优先级和结合性**

如果一个表达式包含了相邻的并列的运算并且没有用括号指定优先级（括号的说明见下面的小节），那么运算的先后顺序就会根据优先级和结合性来决定，规则：
* 优先级高的运算
* 同优先级的按结合性选择自左至右或自右至左进行计算

Larva的优先级设计基本和C++、Java保持一致，下表是按优先级从高到低对运算进行排列说明，并说明每个优先级的运算指定结合性：

|运算               |结合性     |备注                                                       |
|-------------------|-----------|-----------------------------------------------------------|
|`new`              |无         |`new`运算，各个`new`之间不可能并列，无结合性的意义         |
|`[] [:] . ()`      |自左至右   |后缀运算，`.`是取属性或方法的运算，`()`是调用运算          |
|`~ ! + -`          |自右至左   |前缀单目运算，这里的`+ -`是指正负运算                      |
|`* / %`            |自左至右   |算术乘除和取模运算                                         |
|`+ -`              |自左至右   |算术加减运算                                               |
|`<< >>`            |自左至右   |移位运算                                                   |
|`< <= > >=`        |自左至右   |比较大小运算                                               |
|`=== !== == !=`    |自左至右   |判同和判等运算                                             |
|`&`                |自左至右   |按位与                                                     |
|`^`                |自左至右   |按位异或                                                   |
|`|`                |自左至右   |按位或                                                     |
|`&&`               |自左至右   |逻辑与                                                     |
|`||`               |自左至右   |逻辑或                                                     |
|`if-else`          |无         |三目运算符，在结合性方面有特殊规定，见下一小节的详细说明   |

详细说明：
* 请注意“先计算优先级高的运算”是指**相邻并列**的两个运算，而不是整个表达式，例如`a+b-c*d`中，优先级的体现仅在于`*`和`-`两个运算中先算`c*d`，
而前面的`+`和`*`并不相邻，因此`+`只和`-`进行判断比较，二者优先级相同，按结合性是`+`先计算，所以这个式子的计算流程是先计算`a+b`和`c*d`，
然后做`-`，而`-`两边的这两者谁先谁后则没有明确规定，这属于求值顺序的范畴，和优先级无关
* 强制类型转换运算`cast`虽然是一个特殊语法，但在优先级和结合性规则中可看做是一个函数调用的形式
* 格式化字符串的“运算”`.()`虽然是一个特殊语法，但在这里可视为一个省略方法名的方法调用形式（`.format()`这种的简写语法），因此属于后缀运算

### **括号的使用**

在表达式中可以用圆括号`()`改变运算的优先级，括号括起来的作为一个整体的子表达式，例如`(1+2)*3`会先计算括号中的`1+2`和`3`，然后再做乘法，
这和算术中使用括号的方法和含义是一样的

若表达式的运算分量之间，或和运算符在语法上有一些冲突或二义性的时候，也需要用括号来分隔，否则可能出现非预期的效果或错误，
例如创建一个数组并立即取其分片，需要写成`(new int[a])[b : c]`的形式，如果去掉了圆括号，则会被解析为创建二维数组，进而会在分片语法的`:`处报错，
对于多维数组即便是写`new int[d][][e : f]`这种形式也是错误的，因为如果多维数组后面的维度为空，则需要都是空内容的方括号组合，会在`e`处报错，
尽管从人的思考角度可能认为这里没有歧义，但是Larva编译器的分析过程比较机械，因此还是需要写成`(new int[d][])[e : f]`

* *Note*：回忆一下词法分析文档中举过的`1.a()`这个例子，词法分析器会将第一个token解析为`1.`，即一个浮点数字面量，而不是看做对`1`执行方法`a()`，
和这里的问题有相似之处，Larva采用比较机械的语法分析规则是为了实现和理解上的直白简单，而不会引入太多的“智能”识别，这也是减少灵活性，
避免引起更多问题

上面的优先级和结合性表中，对于三目运算符`if-else`的结合性的描述是“无”，这是因为三目运算符如果多个并列连写，很容易造成可读性问题，
因此Larva特别规定了三目运算符多个并列连写的时候一定要加括号进行区分，
例如`a if b if c else d else e`或`a if b else c if d else e`的写法都是非法的，尽管在具体的结合性规则下它们也都有确定含义，
但对读代码的人是个挑战，因此前者必须写成`a if (b if c else d) else e`，
而后者则需要根据实际需求写成`(a if b else c) if d else e`或者`a if b else (c if d else e)`

有些运算符或运算符的某部分本身就是括号或分隔符`:`和`,`，例如`[]`、`[:]`、`()`以及`new ()`、`new {}`等，
这种括号内部的一个或多个表达式是作为子表达式看待，而不是和外层的括号运算符构成并列关系，例如`a[b+c].d`中，`[]`和`.`是并列关系，
而`+`是被`[]`包含的子表达式运算，和后者不是并列关系，因此没有优先级先后的问题

## **求值顺序和副作用**

一个表达式可能有多个子表达式，例如双目运算符的两个运算分量，函数或方法调用的运算中的各参数等，由于做运算需要将各运算分量的值先计算出来，
因此就涉及到一个求值顺序的问题，具体地可以说是一个表达式中各子表达式的计算顺序

Larva并没有严格规定所有运算的求值顺序，有明确规定的只有两类：
1. `&&`和`||`两个逻辑运算符，会先计算左运算分量，然后根据计算的结果来决定是否计算右运算分量
1. `if-else`运算，会先计算条件表达式，根据计算结果决定计算其他两个运算分量中的某一个

对于其他运算，Larva并不规定运算分量中子表达式的求值顺序，例如`f() + g()`，加法的两个运算分量谁先执行是不一定的，
如果开发者需要`f()`比`g()`先执行，可以用变量保存其执行结果再相加，利用语句执行的顺序性来保证两个函数的执行顺序

实际上如果各运算分量之间的计算是各自独立的，不会相互影响，那么求值顺序的改变不会影响到计算结果，但是Larva中的表达式不仅是普通运算求值，
还包含函数和方法调用，而函数和方法调用有可能会产生副作用，包括但不限于修改全局数据（全局变量或堆内存等）、进行IO操作等，
这就可能使不同运算分量的求值（函数或方法的调用执行）之间产生互相影响，例如：
```
int a = 1;

int f()
{
    ++ a;
    return a;
}

public void main()
{
    /*
    如果求值顺序是a、f()，那么结果是1+2=3
    如果求值顺序是f()、a，那么结果是2+2=4
    */
    println(a + f());
}
```
如示例的注释所说，由于两个运算分量都存取了全局变量`a`，则由于不保证求值顺序，结果是不定的，应该避免写出这种代码，如果一定要写，
也应引入临时变量来手动设置执行顺序：
```
public void main()
{
    /*
    如果要求求值顺序是a、f()
    */
    int tmp_a = a;
    int tmp_f_result = f();
    println(tmp_a + tmp_f_result);
}
```

*Note*：
* 赋值语句（包括自增自减）在Larva中是语句而非表达式，因此没有C++、Java等语言中的副作用问题
* Golang在语言标准上是规定了部分求值顺序的，例如一个语句或表达式中的函数或方法调用是从左到右，由于大部分时候Larva代码是直译为Golang代码，
因此也会有类似的行为，不过Larva依然没有将其定死，一方面是我认为复杂的表达式即便有良好的顺序定义，可读性也比较差，
另一方面是为Larva本身的优化留一些空间
