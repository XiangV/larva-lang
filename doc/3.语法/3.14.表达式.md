# **表达式**

## **概述**

表达式是一个可以求值的语法单元，即“执行”其代码是一个求值的过程，执行后会得到一个结果，本文档描述的Larva语法层面的“表达式”是一个广义概念，
因此这里的“结果”分两种：
* “`void`值”，即表达式的执行是一个无返回类型，或者说返回类型为`void`的函数或方法的调用表达式，求值后可以说它没有结果，
也可抽象地说是一个`void`值结果
* 一个数据值，有确定的类型

注：和绝大多数语言一样，Larva支持多运算混合的复杂表达式，本文档中如无特殊说明，“xx运算的表达式”的说法是指“最后一步运算为xx运算的表达式”，
例如：`f(1 + 2).call(a.f() << b)`是一个“对`call`方法进行调用的表达式”，尽管其还有其他子表达式部分

为了方便描述语法，我们将Larva的表达式从形式上进行抽象，分为两大类：

1. 直接取值或取其运算分量含义的表达式，即没有做任何运算，本身就是一个运算分量，包括：

    * 名字，包括模块名、类名、函数名、变量名等，类方法中的`this`关键字也算在内
    * 各种字面量
    * 通过语法`[]{...}`构建的闭包对象

    *Note*：模块名、类名等本身不算做值，但是形式上算作运算分量

1. “运算符”加“运算分量”的形式，这个和AST的结构在形式上是统一的，这里的“运算分量”是一个抽象概念，并不仅仅是参与实际运算的值，例如：

    * `1+2`的运算符是`+`，运算分量是字面量`1`和`2`
    * `f(x, y)`的运算符是`()`（调用运算符，注意和括号的含义区别），运算分量是名字`f`和参数列表`x, y`
    * `new A(100, 200, 300)`的运算符是`new ()`，运算分量是类`A`和参数列表`100, 200, 300`
    * `a.f()`的运算符是`()`，运算分量是一个子表达式`a.f`和空的参数列表，子表达式的运算符是`.`，运算分量是名字`a`和`f`，
    注意子表达式这里可以是指“a模块的f函数”或“a对象的f方法”，从表达式语法分析的角度并不做具体的语义区分

    从这些例子中可看出，虽然Larva语法规定函数和类（还包括方法等）并不是一个有效的数据值，但它们也可看做是一个运算分量，
    而运算符表示运算的含义，即将若干运算分量放在一起进行某种“操作”而形成一个结果值，运算符可能并不是一个简单token，而是一个抽象的概念
    例如上面的运算符`new ()`的含义就是“通过构造方法创建对象实例”，根据`new`关键字的用法，
    也有对应的按属性赋值创建对象实例（`new {}`）和创建数组（`new []...`）等运算符概念，我们也可以将创建对象实例的操作笼统地称为`new`运算

## **语法**

本小节说明各种运算表达式的具体语法和运算规则

todo

## **优先级和结合性**

如果一个表达式包含了相邻的并列的运算并且没有用括号指定优先级（括号的说明见下面的小节），那么运算的先后顺序就会根据优先级和结合性来决定，规则：
* 优先级高的运算
* 同优先级的按结合性选择自左至右或自右至左进行计算

Larva的优先级设计基本和C++、Java保持一致，下表是按优先级从高到低对运算进行排列说明，并说明每个优先级的运算指定结合性：

|运算               |结合性     |备注                                                       |
|-------------------|-----------|-----------------------------------------------------------|
|`new`              |无         |`new`运算，各个`new`之间不可能并列，无结合性的意义         |
|`[] [:] . ()`      |自左至右   |后缀运算，`.`是取属性或方法的运算，`()`是调用运算          |
|`~ ! + -`          |自右至左   |前缀单目运算，这里的`+ -`是指正负运算                      |
|`* / %`            |自左至右   |算术乘除和取模运算                                         |
|`+ -`              |自左至右   |算术加减运算                                               |
|`<< >>`            |自左至右   |移位运算                                                   |
|`< <= > >=`        |自左至右   |比较大小运算                                               |
|`=== !== == !=`    |自左至右   |判同和判等运算                                             |
|`&`                |自左至右   |按位与                                                     |
|`^`                |自左至右   |按位异或                                                   |
|`|`                |自左至右   |按位或                                                     |
|`&&`               |自左至右   |逻辑与                                                     |
|`||`               |自左至右   |逻辑或                                                     |
|`if-else`          |无         |三目运算符，在结合性方面有特殊规定，见下一小节的详细说明   |

详细说明：
* 请注意“先计算优先级高的运算”是指**相邻并列**的两个运算，而不是整个表达式，例如`a+b-c*d`中，优先级的体现仅在于`*`和`-`两个运算中先算`c*d`，
而前面的`+`和`*`并不相邻，因此`+`只和`-`进行判断比较，二者优先级相同，按结合性是`+`先计算，所以这个式子的计算流程是先计算`a+b`和`c*d`，
然后做`-`，而`-`两边的这两者谁先谁后则没有明确规定，这属于求值顺序的范畴，和优先级无关
* 强制类型转换运算`cast`虽然是一个特殊语法，但在优先级和结合性规则中可看做是一个函数调用的形式
* 格式化字符串的“运算”`.()`虽然是一个特殊语法，但在这里可视为一个省略方法名的方法调用形式（`.format()`这种的简写语法），因此属于后缀运算

### **括号的使用**

在表达式中可以用圆括号`()`改变运算的优先级，括号括起来的作为一个整体的子表达式，例如`(1+2)*3`会先计算括号中的`1+2`和`3`，然后再做乘法，
这和算术中使用括号的方法和含义是一样的

若表达式的运算分量之间，或和运算符在语法上有一些冲突或二义性的时候，也需要用括号来分隔，否则可能出现非预期的效果或错误，
例如创建一个数组并立即取其分片，需要写成`(new int[a])[b : c]`的形式，如果去掉了圆括号，则会被解析为创建二维数组，进而会在分片语法的`:`处报错，
对于多维数组即便是写`new int[d][][e : f]`这种形式也是错误的，因为如果多维数组后面的维度为空，则需要都是空内容的方括号组合，会在`e`处报错，
尽管从人的思考角度可能认为这里没有歧义，但是Larva编译器的分析过程比较机械，因此还是需要写成`(new int[d][])[e : f]`

* *Note*：回忆一下词法分析文档中举过的`1.a()`这个例子，词法分析器会将第一个token解析为`1.`，即一个浮点数字面量，而不是看做对`1`执行方法`a()`，
和这里的问题有相似之处，Larva采用比较机械的语法分析规则是为了实现和理解上的直白简单，而不会引入太多的“智能”识别，这也是减少灵活性，
避免引起更多问题

上面的优先级和结合性表中，对于三目运算符`if-else`的结合性的描述是“无”，这是因为三目运算符如果多个并列连写，很容易造成可读性问题，
因此Larva特别规定了三目运算符多个并列连写的时候一定要加括号进行区分，
例如`a if b if c else d else e`或`a if b else c if d else e`的写法都是非法的，尽管在具体的结合性规则下它们也都有确定含义，
但对读代码的人是个挑战，因此前者必须写成`a if (b if c else d) else e`，
而后者则需要根据实际需求写成`(a if b else c) if d else e`或者`a if b else (c if d else e)`

有些运算符或运算符的某部分本身就是括号或分隔符`:`和`,`，例如`[]`、`[:]`、`()`以及`new ()`、`new {}`等，
这种括号内部的一个或多个表达式是作为子表达式看待，而不是和外层的括号运算符构成并列关系，例如`a[b+c].d`中，`[]`和`.`是并列关系，
而`+`是被`[]`包含的子表达式运算，和后者不是并列关系，因此没有优先级先后的问题

## **求值顺序和副作用**

一个表达式可能有多个子表达式，例如双目运算符的两个运算分量，函数或方法调用的运算中的各参数等，由于做运算需要将各运算分量的值先计算出来，
因此就涉及到一个求值顺序的问题，具体地可以说是一个表达式中各子表达式的计算顺序

Larva并没有严格规定所有运算的求值顺序，有明确规定的只有两类：
1. `&&`和`||`两个逻辑运算符，会先计算左运算分量，然后根据计算的结果来决定是否计算右运算分量
1. `if-else`运算，会先计算条件表达式，根据计算结果决定计算其他两个运算分量中的某一个

对于其他运算，Larva并不规定运算分量中子表达式的求值顺序，例如`f() + g()`，加法的两个运算分量谁先执行是不一定的，
如果开发者需要`f()`比`g()`先执行，可以用变量保存其执行结果再相加，利用语句执行的顺序性来保证两个函数的执行顺序

实际上如果各运算分量之间的计算是各自独立的，不会相互影响，那么求值顺序的改变不会影响到计算结果，但是Larva中的表达式不仅是普通运算求值，
还包含函数和方法调用，而函数和方法调用有可能会产生副作用，包括但不限于修改全局数据（全局变量或堆内存等）、进行IO操作等，
这就可能使不同运算分量的求值（函数或方法的调用执行）之间产生互相影响，例如：
```
int a = 1;

int f()
{
    ++ a;
    return a;
}

public void main()
{
    /*
    如果求值顺序是a、f()，那么结果是1+2=3
    如果求值顺序是f()、a，那么结果是2+2=4
    */
    println(a + f());
}
```
如示例的注释所说，由于两个运算分量都存取了全局变量`a`，则由于不保证求值顺序，结果是不定的，应该避免写出这种代码，如果一定要写，
也应引入临时变量来手动设置执行顺序：
```
public void main()
{
    /*
    如果要求求值顺序是a、f()
    */
    int tmp_a = a;
    int tmp_f_result = f();
    println(tmp_a + tmp_f_result);
}
```

*Note*：
* 赋值语句（包括自增自减）在Larva中是语句而非表达式，因此没有C++、Java等语言中的副作用问题
* Golang在语言标准上是规定了部分求值顺序的，例如一个语句或表达式中的函数或方法调用是从左到右，由于大部分时候Larva代码是直译为Golang代码，
因此也会有类似的行为，不过Larva依然没有将其定死，一方面是我认为复杂的表达式即便有良好的顺序定义，可读性也比较差，
另一方面是为Larva本身的优化留一些空间
