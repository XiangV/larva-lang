# **函数**

## **概述**

Larva的函数是模块元素之一，定义在模块的代码中，和其他命令式语言的函数类似
* 函数接受0或多个输入参数
* 函数可返回计算结果，也可以无返回（即返回类型为`void`）
* 函数中可以有副作用，不仅是求值
* 支持递归

本节只说明普通函数的语法，泛型函数的额外内容在泛型一节

## **定义**

函数的定义包括签名和函数体两部分

1. 签名

    语法：`[public] 返回类型 函数名(参数列表)`

    * 如加了`public`修饰，则表示函数从模块外可以访问
    * 返回类型如果不指定，需要用`void`
    * 函数名需要是一个标识符
    * 参数列表是由逗号分隔的0个或多个参数定义
        * 参数定义语法：`[ref] 参数类型 参数名`
        * 关键字`ref`用于指定此参数通过别名引用传递，具体说明见下
        * 参数名需要是一个标识符
        * 参数本身也是函数的局部变量

1. 函数体

    函数体是跟在签名后面，用花括号`{}`包起来的语句列表，各种语句见后面的小节

    函数的返回值由`return`语句指定，如函数返回类型不为`void`且语句列表末尾没有`return`，则编译器会在最后附加一个`return`返回返回类型的零值，
    详细说明参考`return`语句一节

    注：这里的语句列表不单是各种语句，也可插入Native代码，具体内容参考‘5.Native代码开发’一节

## **局部变量**

* 函数参数和函数体中定义的变量是当前函数的局部变量

* 参数之外的局部变量定义语法

    1. 指定类型定义：`类型 变量名 [= 初始化表达式][, 变量名 [= 初始化表达式]]...[,];`
    1. 通过`var`定义：`var 变量名 = 初始化表达式[, 变量名 = 初始化表达式]...[,];`，即必须指定每个变量的初始化，变量类型为初始化表达式的结果类型
    1. `foreach`语句的定义：`foreach ({var ¦ 类型} 变量名 : 迭代器表达式)`

    详细说明请参考‘3.4.变量和类型’中的局部变量说明

* 局部变量的作用域、定义规范等参考‘3.8.名字查找’

* 局部变量的初始化表达式中不能用到被定义的局部变量本身，即便是通过闭包代码涉及到而非实际用到也不行

    例：
    ```
    void f()
    {
        int a = a;  //错误，在初始化a的时候引用到了a

        /*
        b的定义是错误的，在初始化b的时候引用了b
        虽然这个初始化只是对闭包对象本身求值，并不会立即调用，看上去语法没有问题，但由于检查过于繁琐，因此Larva采用比较严格的控制
        */
        var b = []{
            int f(int n)    //Note：方法名字不要求和外层变量名不冲突，详情参考类的说明的章节
            {
                return 1 if n == 0 else b.f(n - 1) * n;
            }
        };

        //若一定要实现上面b的这种效果，即闭包递归调用自身，可以这样
        /*
        interface BIntf
        {
            int f(int n);
        }
        */
        BIntf b;
        b = []{
            int f(int n)
            {
                return 1 if n == 0 else b.f(n - 1) * n;
            }
        };
    }
    ```

## **调用和返回**

由于Larva中没有单独的函数类型，函数不能单独作为一个值使用，只能用于调用，即代码中用到函数的地方都必须配合`()`运算符

* *Note*：如果需要像Python、Golang中将函数本身传给其他变量来调用，可用闭包实现，Larva不引入函数类型主要还是函数类型的语法表示较为繁琐，
不如独立写成接口清晰

函数调用语法：`[模块名.]函数名(参数列表)`，是否加模块名由调用者和被调用者的关系决定（本模块的函数或`__builtins`模块的public函数不需要）

函数调用是一个表达式，其类型是函数的返回类型

### **参数传递**

Larva提供了两种传递参数的方法：

1. 赋值传递，相当于赋值操作，即基础类型传值，类和接口传句柄引用
1. `ref`别名引用传递，和赋值传递的区别在于，函数参数是传入的左值参数的别名，在函数内部对参数的赋值等同于对这个左值赋值

这里详细说一下`ref`传递别名引用的语法，和普通参数传递有几点区别：
1. 输入参数必须对参数表达式指定`ref`修饰，表达式必须是个可修改的左值，且类型必须和参数一致

    例：
    ```
    void f(ref int i)
    {
    }

    final int g = 123;

    void h(ref Any a)
    {
    }

    public void main()
    {
        f(ref 1);                   //错误，1不是左值
        f(ref g);                   //错误，g是常量（不可修改的全局变量）
        int x;
        f(x);                       //错误，缺少ref修饰
        f(ref x);                   //正确
        f(ref (new int[10])[0]);    //正确，数组的下标表达式是左值
        h(ref x);                   //错误，类型不匹配，虽然int可以隐式转为Any，但是ref要求完全匹配
    }
    ```

1. 在函数内部使用这个参数时，对其赋值和取值等同于对其引用的左值的赋值和取值

    例：
    ```
    void f(ref int i, int j)
    {
        ++ i;
        ++ j;
    }

    public void main()
    {
        int i = 123, j = 456;
        f(ref i, j);
        println("%d %d".(i, j));    //输出“124 456”，i被改变，j没有被改变
    }
    ```

1. 若在函数中用这个参数传递给另一个函数的`ref`参数，则相当于别名传递，若传递给普通参数则相当于普通传递

    例：
    ```
    void f1(ref int i1)
    {
        ++ i1;
    }
    void f2(ref int i2)
    {
        f1(ref i2);
    }

    void g1(int j1)
    {
        ++ j1;
    }
    void g2(ref int j2)
    {
        g1(j2);
    }

    public void main()
    {
        int x = 123;
        f2(ref x);
        println(x); //输出“124”，x被改变
        g2(ref x);
        println(x); //输出“124”，x没有被改变
    }
    ```
    在这个示例中，`f2`中的`i2`是对`x`的别名引用，调用`f1`时，`f1`中的`i1`也是别名引用，因此它们都引用了`x`这个变量，
    对`i1`或`i2`赋值都会导致x的值变化，而调用`g2`的时候虽然也是`ref`传递，但是`g2`调用`g1`的时候是赋值传递，
    实际相当于取了`j2`所引用的`x`的值然后赋值给`j1`，因此在`g1`中对`j1`的修改是不会影响`x`的

1. 可以用`ref _`来省略参数，这种情况下被调用的函数的对应参数会收到一个匿名左值的别名引用，值为对应类型的零值

    例：
    ```
    void f(ref int i)
    {
        println(i); //输出0
        ++ i;
        println(i); //输出1
    }

    public void main()
    {
        f(ref _);   //传入的匿名左值虽然在f中被修改了，但调用者不关心也拿不到结果

        /*
        上面代码相当于：
        int tmp;
        f(ref tmp);
        */
    }
    ```

简单总结就是：`ref`别名引用是对变量的引用，但是在使用上自动解引用，而在‘3.4.变量和类型’中讲到的句柄引用则是对数据的引用，相当于指针

*Note*：`ref`语法就是抄C#的，也可以对照理解，其实如果设计了多值返回语法的话，就完全不需要`ref`了，不过这属于Larva早期设计方向的问题，
当时就定下来用`ref`，后面也不想改了，如果读者熟悉C++，也可以直接理解为C++的引用，需要注意的是对`ref`参数传递句柄引用时，
由于句柄引用本质是指向结构体的指针，所以传入的实际是“结构体指针左值的引用”，在Native Go代码中的实现是一个二级指针，
具体在‘5.Native代码开发’中还会详细说明原理
