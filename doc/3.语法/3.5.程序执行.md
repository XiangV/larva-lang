# **程序执行**

本节说明Larva程序的执行流程相关的规则

## **程序启动**

### **初始化**

一个Larva程序启动后首先要做的是各模块的初始化工作，每个模块的初始化流程包括所有全局变量的初始化，即计算每个全局变量的初始化表达式并赋值

模块初始化是按照依赖关系进行的，一个模块在初始化之前会先保证其依赖的模块都进行了初始化工作，每个模块只会初始化一次

*Note*

* 初始化原则上是从main模块开始对所有依赖模块进行递归处理，不过标准库几个默认导入的私有模块是编译器和私有库自行处理的
* 目前Larva还没有做模块的`init`函数之类的初始化机制，留一个TODO项，暂时可用Native代码中写Go的`init`函数来实现，但后者有初始化顺序问题

### **main函数**

一个Larva程序在编译时需要指定主模块，主模块和其他模块的区别在于：程序启动时以主模块的main函数作为入口

main函数的签名必须是：`public void main()`，程序在做完所有初始化工作后将调用它

## **程序结束**

Larva程序的结束有正常和非正常结束两种，其中正常结束是指：
1. 从main函数中return，程序的退出码为`0`
1. 主fiber出现未捕获的异常而退出，此时会在标准错误输出打印异常信息，程序的退出码为`2`

*Note*：fiber的概念和说明见‘3.6.并发模型’，异常的概念和说明见下面的‘错误处理’一节

非正常退出是指：
1. 接收到操作系统某些信号，并且程序没有捕获处理而导致的退出
1. 在Native代码中直接调用类似`os.Exit`的接口直接退出
1. 运行时引发Go的`panic`而崩溃退出，此时会在标准错误输出额外打印出崩溃时的Larva调用栈
1. 其他原因导致的程序崩溃，例如使用了cgo代码导致C语言层面的coredump等

如果出现非正常退出，基本都是代码本身有问题，应排查问题并修复

## **错误处理**

### **异常**

Larva的错误处理一般使用异常（Exception）的方式，异常会从抛出的点回溯当前fiber的调用栈，直到被代码显式捕获，
或者到栈顶被fiber的入口函数默认捕获为止，被捕获的异常会被封装成泛型类`Catched<T>`的对象实例，其中包括原始异常和发生异常时的调用栈信息

异常对象可以使用任何实现了`Throwable`接口的类的对象实例，用内建函数`throw`抛出

例：
```
void f(Callable c)
{
    c.call();
}

public void main()
{
    f([-]{
        throw("exception");
    });
}
```
将以上代码保存在本地开发的模块中，例如在我的测试环境下，模块名为`tmp`，由于main函数中没有捕获抛出的异常，运行后会打印调用栈和异常信息后退出：
```
Traceback (fiber[main]):
  File "/home/xtlisk/larva/tmp/tmp.lar", line 8, in tmp.main
  File "/home/xtlisk/larva/tmp/tmp.lar", line 3, in tmp.f
  File "/home/xtlisk/larva/tmp/tmp.lar", line 9, in closure[tmp:tmp.lar:8:7].call
String: exception
```
输出说明：调用栈的第一行的`Traceback`后面的括号中指明了出现异常的fiber名字，Larva的主fiber默认名字为“main”，
接下来用多个带两空格缩进的行指明了调用栈各层的文件、行号、所在函数或方法名的信息（顺序从栈底到栈顶，即调用者在上面），
其中闭包的函数名中用中括号指明了闭包所在的文件和行、列位置，方便排查问题，最后一行指明了抛出的异常对象的类型和其`str`方法返回的信息

*Note*：当然，如果开发者坚持用返回值的形式来指明错误也是可以的，但Larva的风格是正常代码用异常，
一些比较特殊的地方才用返回值的方式指明或规避错误（例如反射相关接口的使用）

### **异常的捕获**

如上所述，Larva的异常在抛出时会将异常对象和调用栈信息打包为一个`Catch<T>`的对象实例，因此捕获的时候是捕获到这个对象实例，后续统称“异常”，
根据上下文应该能比较容易地判断具体含义

Larva标准库提供了两种捕获异常的方式

#### **手动catch**

在defer中通过内建泛型函数`catch<T>`捕获，类似Go的`recover`，若没有异常，则返回nil，若有异常但不是指定的捕获类型，则继续往上抛

规则：
1. 若要捕获抛到当前函数（当前函数代码抛出或下层函数抛出没处理，上抛到当前函数）的异常，调用`catch`的位置必须符合要求之一：
    1. 在`defer`代码块中调用`catch`
    1. `defer`的表达式是一个函数调用，在此函数中调用`catch`
    1. `defer`的表达式是一个非闭包的类对象实例的非`usemethod`方法调用，在此方法中调用`catch`
    
    *Note*：这三条跟Go的`recover`相关规则类似，需要注意的是第三条需要方法是普通类的普通方法，而不能是闭包的方法或类中通过`usemethod`继承的方法，
    因为后两者的实现有多层嵌套调用，`usemethod`机制参考类的相关章节

    例：
    ```
    void deal_with_exc(Catched<String> c)
    {
        if (c !== nil)
        {
            println(c.throwed());
            println(c.traceback());
        }
    }

    void f()
    {
        deal_with_exc(catch<String>());
    }

    class A
    {
        void f()
        {
            deal_with_exc(catch<String>());
        }
    }

    class B
    {
        A a usemethod;
    }

    public void main()
    {
        defer
        {
            deal_with_exc(catch<String>());
        }
        /*
        //这样也都是可以捕获的
        defer f();
        A a;
        defer a.f();
        */
        /*
        //这样都是不行的
        defer [-]{
            deal_with_exc(catch<String>());
        }.call();
        var b = new B{};
        defer b.f();
        */
        throw("exc");
    }
    ```

    由于`defer`代码块在实现上是一个匿名的闭包函数，嵌套的`defer`是以上层`defer`代码块为边界的，因此在异常捕获上也需要注意一下，例如：
    ```
    public void main()
    {
        defer   //第一个defer
        {
            println(catch<Throwable>().throwed());  //输出“exc in main”
        }
        defer   //第二个defer
        {
            defer   //内层defer
            {
                println(catch<Throwable>().throwed());  //输出“exc in defer”
            }
            throw("exc in defer");
        }
        throw("exc in main");
    }
    ```
    这就是说，如果defer中在没有捕获当前异常的情况下又抛出异常，则两个异常会暂时“共存”，例如上面的例子，`"exc in defer"`被抛出时，
    是从属于第二个defer代码块的，而先前被抛出的`"exc in main"`从属于main函数的代码块，如果第二个defer的异常被其内层defer捕获了，
    则第二个defer就像没有发生异常一样正常执行完毕，main函数代码块的异常将交由第一个defer的代码去捕获

    而如果上面例子中第二个defer代码块没有捕获自己的异常，那么它的异常就会上抛到main函数代码块这一层，覆盖掉main函数原有的异常，
    从而被第一个defer的代码捕获到：
    ```
    public void main()
    {
        defer   //第一个defer
        {
            println(catch<Throwable>().throwed());  //输出“exc in defer”
        }
        defer   //第二个defer
        {
            throw("exc in defer");
        }
        throw("exc in main");
    }
    ```
    总结一下：
    1. 异常有对函数（或方法）调用栈的栈帧的从属概念
    1. 异常抛出时，属于调用`throw`的栈帧
    1. 某一栈帧的异常可以在它的`defer`调用的下一级栈帧中用`catch<T>`捕获
    （但是如上所述只有函数或普通类的方法，闭包的方法或`usemethod`的方法有一些额外栈帧，所以会有问题）
    1. 如果异常在当前栈帧所有defer执行完成后还没有被捕获，就上抛到上一个栈帧
    1. 如果某栈帧已经有异常，又收到下一帧上抛的异常，则上抛的异常覆盖掉原有的异常

1. 必须指明捕获的异常类型，异常类型可以是接口或类，若异常对象的类型是指定的类或实现了指定接口，则捕获成功，否则不捕获而是重新抛出，
交给后面的流程

    例：
    ```
    public void main()
    {
        defer
        {
            println(catch<Throwable>() !== nil);    //已经无异常了，输出false
        }
        defer
        {
            println(catch<String>() !== nil);       //异常是String类型，输出true
        }
        defer
        {
            println(catch<IndexError>() !== nil);   //无输出，因为catch中发现异常不是IndexError类型，重新抛出了
        }
        throw("exc");
    }
    ```
    *Note*：显然`catch<Throwable>()`可以捕获所有异常，可以利用这个来忽略异常

1. 异常被捕获后，同一层次的后续捕获操作将返回无异常，捕获到的`Catched<T>`的对象实例也可通过调用`rethrow()`方法来重新抛出

    例：
    ```
    public void main()
    {
        defer
        {
            println(catch<Throwable>() !== nil);    //捕获到了重新抛出的异常，输出true
        }
        defer
        {
            var c = catch<String>();
            if (c !== nil)
            {
                println("catched String");
                c.rethrow();
            }
        }
        throw("exc");
    }
    ```

    注意：`rethrow()`是将捕获到的`Catched<T>`的对象实例中的异常和调用栈信息重新打包抛出，就好像没被捕获过一样，
    但上抛的是一个新的`Catched<T>`对象实例。需要理解下`rethrow()`和在当前位置`throw(catched_obj.throwed())`的区别，
    后者相当于以当前位置的调用栈信息重新包装异常再抛出，调用栈更换为当前位置

#### **使用call_and_catch**

由于手动调用`catch<T>`有一些局限性，例如需要考虑位置、`defer`表达式只能是只支持普通函数和方法等，代码也有些繁琐，容易出错，考虑这些问题，
标准库提供了另一个泛型函数`call_and_catch<T>`来处理异常的捕获：
```
//调用输入的Callable对象的call方法，如果出现异常且异常对象类型是T或实现了T接口，则以返回值的形式返回捕获的Catched<T>对象实例
public Catched<T> call_and_catch<T>(Callable callee)
{
    实现略
}
```

例：
```
public void main()
{
    var c = call_and_catch<String>([-]{
        throw("exc");
    });
    if (c !== nil)
    {
        println(c.throwed());   //输出“exc”
    }
}
```

这种形式有点类似其他语言的`try catch`语法，也避免了`defer`的相关问题，不过只能指定一个需要的异常类型，如果有多个异常类型需要判断，
可以先`call_and_catch<Throwable>`，然后对结果依次做`try_assert_type`，或者嵌套多层

`call_and_catch`的泛型参数的含义和上面`catch`的相同，如果当前异常不符合需要的类型则会重新抛出

### **异常的默认处理方式**

如果异常没有被Larva代码捕获，就会一直上抛到当前fiber的入口处，根据所处不同fiber，有三种处理方式：
1. 对于主fiber，异常将被打印在标准错误输出，然后程序退出，退出码为`2`
1. 如果是一个worker fiber，异常将被发送到`Worker`对象实例的等待通道  
*Note*：worker fiber的内容参考‘3.6.并发模型’和`fiber`模块的说明
1. 其他普通fiber，异常将被打印在标准错误输出，然后fiber结束，程序不受影响
