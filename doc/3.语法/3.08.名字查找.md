# **名字查找**

## **概述**

名字查找是指代码中出现引用一个独立标识符时，通过查找确定其具体含义的过程，为了简化名字查找规范并使得代码更加明确化，提高可读性，
Larva对命名时的名字冲突情况做了较严的限制

*Note*
* 注意是“引用”，即使用到，而不是定义它的时候，这里说的是标识符，即“定义”也是一个广义的含义，比如导入模块的名字，
也可看做是`import`在“定义”，不过模块名还是有它一些特殊的地方的，见下
* 标识符需要是独立引用的，即不能作为其他的元素、属性或方法，例如`a.b`、`c.d.e()`中的独立引用的标识符是`a`和`c`

## **命名限制**

Larva在名字方面的限制非常严格，绝大多数名字隐藏（当前代码块定义的名字隐藏上层）都是不允许的，包括：

* 同一个文件中不允许导入的模块名存在重名，如果存在同名模块，可通过别名语法规避，见‘3.3.模块导入’

    *Note*：本文提及的“模块名”都是指导入后引用模块时用的名字，即如果定义了别名，则指别名

* 模块元素的名字不能和同模块中其他模块元素名重名，不能和`__builtins`模块的public元素名重名，也不能和当前文件中模块导入的模块名重名

    例：
    ```
    import os;

    int os;     //错误，和导入模块名重名

    int f;
    void f()    //错误，和其他模块元素（全局变量“f”）重名
    {
    }

    int String; //错误，和__builtins.String重名
    ```
    需要注意这条规定并不限制某个模块元素和**同模块中其他文件引用的模块名**相同，例如一个模块有两个代码文件`a.lar`和`b.lar`：
    ```
    //a.lar-----------------------------
    import os;
    public void main()
    {
        println(os);
    }

    //b.lar-----------------------------
    int os = 123;
    ```
    示例中`a.lar`会编译出错，这个代码文件中的`os`是导入的模块名，编译器会提示`println(os);`的`os`后面少了个`.`，
    也就是说导入的模块名会隐藏同模块其他文件中定义的同名全局变量名，使得`a.lar`中的`os`是指当前文件导入的模块而非其他文件中的全局变量，
    这一点对于函数、类、接口等其他模块元素也是一样的规则

    一般来说当然是尽量避免模块元素和常见模块同名，如果发生冲突了可以从代码结构入手，例如多弄几个代码文件，将使用和模块导入分开即可

* 局部变量不能和同模块的模块元素名、所在文件的导入模块名、以及`__builtins`模块的public元素重名，在同一代码块中也不能重复定义

    例：
    ```
    import os;

    void f()
    {
        int os; //错误，和模块名重名
        int f;  //错误，和当前模块函数重名
        int a;
        int a;  //错误，重复定义
    }
    ```

* 如果函数、方法存在嵌套代码块，则内层代码块的局部变量也不能定义位置之前的已定义的局部变量重名

    例：
    ```
    void f()
    {
        int a;

        {
            int a;  //错误，和上层局部变量重名
        }

        {
            int b;  //正确，虽然上层也有一个变量b，但是定义在本代码块之后，不会有歧义
        }

        int b;
    }
    ```

* 对于函数或方法的闭包，其局部变量（包括参数）是闭包自己的，但由于闭包内部能引用外层函数的局部变量，
因此闭包的局部变量仍然不能和任何定义在闭包之前的外层局部变量、导入模块名、同模块的模块元素名、以及`__builtins`模块的public元素重名

    例：
    ```
    void f()
    {
        int a;
        var c = []{
            void f(int c)   //错误，外层有局部变量c；不过f这里是正常命名，见下
            {
                int a;      //错误，外层有局部变量a
            }
        };
    }
    ```

* 类中的属性和方法、接口中的方法、闭包中的方法都不能重复定义，类中的属性和方法之间也不能有重名的

    例：
    ```
    class C
    {
        int a;
        void a()    //错误，和属性a重名
        {
        }
    }

    interface I
    {
        void f();
        void f();   //错误，方法重复定义
    }

    void f()
    {
        var c = []{
            void f()
            {
            }

            public void f(int x)    //错误，方法重复定义
            {
            }
        };
    }
    ```

* 类的属性和普通方法都不能和当前类名同名，因为类名是特别规定用作构造方法名

* 类的属性和方法、接口的方法、闭包的方法的命名等**可以**和导入模块名、模块元素名、局部变量名等重名

    例：
    ```
    import os;

    int a;

    class C
    {
        int os;     //合法
        void a()    //合法
        {
        }
    }

    interface I
    {
        void a();   //合法
    }

    void f()
    {
        var c = []{
            void f()    //合法
            {
            }
        };
    }
    ```
    *Note*：这是因为以上这些不能直接通过标识符来使用，必须通过`this.属性或方法`或`表达式.属性或方法`来使用，所以不存在歧义

* 泛型类的泛型参数名不能和类名相同

* 泛型类、泛型接口、泛型函数的泛型参数名不能和当前文件的导入模块名重名

* 泛型类的方法和泛型函数中的局部变量不能和泛型参数重名

## **名字查找**

Larva的规则是按照`局部变量->泛型参数->模块元素和当前文件的导入模块名->__builtins模块的public元素`的顺序确定代码中引用到的一个标识符的含义

由于有了严格的命名限制，名字隐藏的情况就很少见了，一个标识符引用基本都不会有歧义（如果有，以后可能会再改进）
