# **词法元素**

本节用于说明Larva代码的各词法元素的规则

对于编译器来说，输入的源代码文件可看做是一个字符序列，第一步工作就是做词法分析，将文件内容分割为一个个“词”（后简称“token”），
本节说明的词法元素是指Larva的各类词法

## **词法分析规则**

1. **忽略间隔空白**

    词法元素之间的空白（制表符、空格、换行）将被忽略，即间隔的空白符不参与实际词法和语法，在词法分析过程中会被忽略，
    例如以下代码在词法上都是合法的：

    ```
    int i=1;
    int j      =         i +3;
    int
    k
    =
    -
    (
    i
    +
    j
    )
    ; //int k = -(i + j);拆成每行一个token
    ```

    *Note*：和大部分语言一样，Larva推荐用适当空格、空行分隔的方式来提高代码可读性

    *Note*：注意这里说的是“词法元素之间的间隔空白”，块注释和原始字符串等跨行的词法元素本身可以包含空白符的，并不会被忽略，
    但编译器也会考虑到代码的可读性，对原始字符串中的某些空白做适当警告，具体见字符串字面量小节

1. **最长子串原则**

    * **原则**

        Larva的词法分析遵循最长子串原则，即在分析一个token的时候，如果可能有多种选择，会从当前位置开始选择最长的一个合法选择，例如：

        ```
        //      //单行注释开始符是一个整体，不会被解析为两个除号
        /**/    //同上，块注释开始符不会被解析为除号和乘号
        ++a;    //对a做++自增，而不是两个+号
        123abc  //由于整数字面量允许后缀（见相关小节），这里不会被解析为123和abc两个词
        1.f();  //看上去是对“1”做方法调用，但由于浮点数支持省略尾数0，因此第一个词是“1.”
        a.123   //被解析为“a”和“.123”，因为浮点数可以省略前导0
        ```

        *Note*：上面这些例子只是作为最长子串原则的示例，其实大部分也都是语法错误，正常代码中不会出现

    * **特例**

        在有的语法设计下，最长子串原则可能会和人的习惯相悖，在Larva的泛型语法中存在一个特例：由于泛型类型实例化的语法是用尖括号“<>”，
        如果存在多层嵌套的话，右侧的“>>”按照最长子串原则将被解析为右移运算符，编译器在这里做了特殊处理，如果发现是嵌套的泛型类型实例，
        则将其视为两个“>”，由于泛型参数只可能是类型，不存在运算，因此不会出现歧义，例如：
        ```
        Iter<Iter<int>> it; //这里的“>>”被视为两个独立的“>”
        ```
        当然也可以将复杂的泛型实例分层写，提高可读性：
        ```
        Iter<
            Iter<int>
        > it;
        ```

## **注释**

Larva的注释分两种形式，除了注释说明外没有其他实质性的功能，在词法分析阶段只是简单将其丢弃掉

* **单行注释**

    单行注释以`//`开头，到所在行末尾，示例：

    ```
    int a = 0;  //这是一个单行注释
    int[] b = new int[]{
        1,  //插在跨行代码中的单行注释
        2,  //注释
    };
    ```

* **块注释**

    块注释以`/*`开头，`*/`结尾，可以跨行，例如：

    ```
    int a/*a的作用是……*/ = 123;
    /*
    b的作用是……
    */
    int b = 456;
    ```

* *Note*

    注释的解析是先分析开始标记，然后以当前行结束（单行注释时）或向前找到结束标记（块注释时），
    编译器不关心注释内容，因此块注释不能嵌套，只是简单扫描文件内容，找到结束标记`*/`

    字符串字面量的值是引号中的所有字符，不能直接在中间写注释，例如：

    ```
    String a = "hello /*这不是注释，是字符串的一部分*/world";
    String b = `hello //同上
    world`;
    ```

    这一点在Native代码的token中也是一样的

## **关键字**

Larva关键字（有的语言中也叫保留字）用于在代码中描述对应的语法，不可将其用作标识符

关键字列表：

```
from    import
class   interface
public  usemethod   final   ref
void    bool        schar   char    short       ushort  int     uint    long    ulong   float   double
foreach for         while   break   continue    if      else    return  defer
nil     true        false   this
var
new     cast
_
```

具体每个关键字的用法参考相关语法章节

*Note*：单下划线“\_”是一个关键字，这个会用在一些变量和值的特殊处理中，例如用于忽略某个值的输出等，这在Golang或Python等语言中也是一个惯例，
所不同的是在这些语言中“\_”在词法上是一个普通的标识符，而在语法上做了特殊处理，如Golang不允许将其作为值直接使用，Larva则采用更直接的方式，
将其作为关键字，杜绝了用其当变量的可能

*Note*：关键字的设计思路是尽量与现有语言接近，如果是多单词组合，则采用小写连写不加下划线分隔的方式，从风格上和变量名等做区别，
如“usemethod”、“foreach”等

## **标识符**

标识符用于类名、接口名、变量名、函数名、模块名等可自定义的名字，规则：

1. 格式：`[A-Za-z_][A-Za-z_0-9]*`，意即字母或下划线开头，由字母数字下划线组成
1. 不能和关键字相同
1. 长度无限制
1. 大小写敏感，例如`time`和`Time`是不同的名字
1. 普通标识符不能为内建宏的形式，即不能同时以双下划线开头和结尾，内建宏的说明见下
1. 不强制要求标识符命名规范和风格

*Note*：Larva的标识符风格建议（和Python较接近）：

* 类、接口名采用大写字母开头的驼峰形式，如“String”、“Callable”等
* `final`修饰的全局变量（初始化后不可修改，也可叫做常量）用下划线连接全大写词的形式，如“BUF_SIZE”等
* 变量、函数名采用下划线连接全小写词的snake形式，如“recved_len”、“make_pair”等
* 模块名风格基本和变量和函数名风格相同，但标准库的第一级模块例外  
*Note*：标准库第一级模块强制要求不能有常规下划线，见“2.2.程序结构”中关于模块组织的限制说明，这个只需要开发语言的人注意一下就好，
普通开发者无需关心
* 如果一个名字是用于比较“私有”的功能或非正式功能，可用单下划线开头

### **内建宏**

内建宏是指同时以双下划线作为开头和结尾的特殊标识符，这些宏会在词法分析阶段由编译器做替换，
主要功能是能将一些编译环境、代码上下文的信息直接插入代码中

目前支持的内建宏有：

|内建宏             |类型       |说明                                                                                  |
|-------------------|-----------|--------------------------------------------------------------------------------------|
|`__PLATFORM__`     |`String`   |编译环境的平台全名，例如“Linux-2.6.32-754.el6.x86_64-x86_64-with-centos-6.10-Final”   |
|`__MACHINE__`      |`String`   |编译环境的机器硬件名，例如“x86_64”                                                    |
|`__SYSTEM__`       |`String`   |编译环境的系统名，例如“Linux”                                                         |
|`__MODULE__`       |`String`   |当前模块名，例如“os/path”                                                             |
|`__FILE__`         |`String`   |当前源代码文件名，一般为绝对路径形式                                                  |
|`__LINE__`         |`int`      |当前行在文件中的行号（从1开始）                                                       |
|`__TIMESTAMP__`    |`long`     |执行编译的Unix时间戳，精确到毫秒                                                      |

如果代码中出现了不能识别的内建宏，则编译报错

*Note*：内建宏的初衷是将编译环境信息插入代码，这样编译出来的程序就可支持类似`version`选项来查看编译来源之类
（比如还可加上git commit hash之类的信息），不过更好的办法似乎是用编译脚本来管理，采用生成信息代码的方式

## **符号**

Larva中的符号主要起到分隔、运算和标记等作用

### **普通符号**

普通符号在词法分析的时候，都作为一个独立的token，主要起到分隔符和运算符的功能

Larva的普通符号包括：

```
.       ..
(       )       [       ]       {       }       :       ;       ,
~       !       +       -       *       /       %       &       |       ^       <<      >>
<       >       !=      ==      !==     ===     <=      >=      &&      ||
=       +=      -=      *=      /=      %=      &=      |=      ^=      <<=     >>=     ++      --
```

各符号在不同语法中可能有不同的含义，在具体的语法说明中会提到，这里只是从词法元素的角度将其罗列出来

### **标记符号**

标记符号和普通符号不同，它们不是单独的token，而是对一个复杂token进行标记，主要有以下几种：

1. 字符、字符串字面量的引号：`'`、`"`、`` ` ``
1. 注释的开始和结束标记：`//`、`/*`、`*/`
1. Native代码的开始和结束标记：`!<<`、`!>>`
1. 编译控制命令的开始标记：`#`

*Note*：Native代码和编译控制命令的标记对于格式有一定要求，见本文下面的‘特殊词法’一节

## **字面量**

字面量是一大类token，用于在代码中表示固定值，类似“立即数”的概念

*Note*：有些文章或书中字面量（literal）也被称为常量（constant），本文档会尽量区分这两种的含义，
“常量”更多指一个不可修改的（如final修饰）变量这种被命名的东东

### **布尔型字面量**

布尔型值只有真假两个，字面量用`true`和`false`两个关键字表示，类型为`bool`

### **字符字面量**

Larva中的字符是指0~255范围的单字节，类似组成Python2的字符串的字符，或Go的byte概念，字符类型相当于8位无符号整数，本身也是整数类型的一种

字符字面量是指用单引号括起来的，单个字符或单个字符的换码序列（转义）的token，类型为`char`，例如：

```
'a'
'\0'
'\177'
'\xef'
'\x0D'
```

#### **换码序列**

换码序列用于在字符字面量或普通字符串字面量中对字符进行转义表示，一般用于无法表示或不方便表示的字符

换码序列表：

|换码序列                   |说明                                           |
|---------------------------|-----------------------------------------------|
|`\\`                       |反斜杠`\`                                      |
|`\'`                       |单引号`'`                                      |
|`\"`                       |双引号`"`                                      |
|`\a`                       |响铃，即`'\x07'`                               |
|`\b`                       |退格，即`'\x08'`                               |
|`\f`                       |换页，即`'\x0C'`                               |
|`\n`                       |换行符                                         |
|`\r`                       |回车符                                         |
|`\t`                       |水平制表符                                     |
|`\v`                       |垂直制表符，即`'\x0B'`                         |
|`\d`<br>`\dd`<br>`\ddd`    |用1到3位的八进制数字（0~7）表示对应号码的字符  |
|`\xHH`                     |用2位十六进制数字（0~F）表示对应号码的字符     |

换码序列规则说明：

1. 在字符字面量或普通字符串字面量中以`\`开头，并符合上述形式，若`\`后的代码不符合规定的形式或规则，则编译报错
1. 单双引号的转义主要是为了和字面量的开始结束标记区分，如果标记不同也可不用转义，例如字符串中的单引号`"'"`、双引号字符字面量`'"'`都可省略转义符
1. 八进制换码序列可由1到3个数字组成，编译器会在这个范围内选择最长的合法八进制数，再根据其值确定表示的字符，例：
    1. 由于合法数字是0~7，因此`'\128'`中的内容被解析为`'\12'`和`'8'`，单引号中出现两个字符，不是合法的字符字面量
    1. `'\432'`中的内容被解析为编号为八进制的“432”的字符，即282号字符，这个范围已经超出0~255了，也不是合法的字符字面量
1. 十六进制换码序列的形式是固定为2位十六进制数字，数字不区分大小写，一般推荐用大写

### **整数字面量**

Larva的整数类型有八种，均由关键字表示，这里简单列一下八种类型的信息，在类型相关小节还会详细说明：

|类型       |位数（字节数） |符号性 |取值范围                                   |
|-----------|---------------|-------|-------------------------------------------|
|`schar`    |8位（1字节）   |有符号 |-128~127                                   |
|`char`     |8位（1字节）   |无符号 |0~255                                      |
|`short`    |16位（2字节）  |有符号 |-32768~32767                               |
|`ushort`   |16位（2字节）  |无符号 |0~65535                                    |
|`int`      |32位（4字节）  |有符号 |-2147483648~2147483647                     |
|`uint`     |32位（4字节）  |无符号 |0~4294967295                               |
|`long`     |64位（8字节）  |有符号 |-9223372036854775808~9223372036854775807   |
|`ulong`    |64位（8字节）  |无符号 |0~18446744073709551615                     |

如上表，整数的八种类型就是1、2、4、8字节的有符号和无符号整数类型，注意`schar`和`char`的命名方式和其他类型不同，因为字符是无符号的

虽然整数类型有这么多，但是整数字面量的类型只有五种：`char`、`int`、`uint`、`long`和`ulong`，其中字符字面量已经在上小节说过，
这里主要说明一下其余四种

整数字面量的正则格式很简单：`\d\w*`，即一个数字开头，后面跟数字字母下划线的一个token，可分为三个部分：

1. 前缀，用于表示进制信息

    |前缀                   |说明       |
    |-----------------------|-----------|
    |无                     |十进制     |
    |`0b`<br>`0B`           |二进制     |
    |`0`<br>`0o`<br>`0O`    |八进制     |
    |`0x`<br>`0X`           |十六进制   |

    *Note*：虽然大小写都可以，八进制也可省略第二位的字母`o`或`O`，但推荐还是统一使用小写的`0b`、`0o`和`0x`，提高可读性

1. 数值部分，即符合前缀指定进制的数字序列，十六进制下的a~f使用大小写都可以

1. 后缀，可用于确定类型

    |后缀                           |字面量类型 |
    |-------------------------------|-----------|
    |无                             |`int`      |
    |`u`<br>`U`                     |`uint`     |
    |`l`<br>`L`                     |`long`     |
    |`ul`<br>`uL`<br>`Ul`<br>`UL`   |`ulong`    |

    通过前缀和第二部分的数字解析出的整数值必须在根据后缀确定的字面量类型所支持的范围内，否则编译出错

    *Note*：虽然后缀用大小写都可以，但推荐统一用大写，这样也可以避免`l`被错认为`1`的问题

    *Note*：不带后缀的整数字面量的类型实际是一个内部类型`literal_int`，在语法处理上有一些特殊的地方，参考类型系统小节

一些整数字面量的例子：

```
123
0b10001U
0o177L
0xABFUL
```

### **浮点数字面量**

Larva的浮点数类型有`float`和`double`两种，对应IEEE754规定的32位和64位浮点数（也叫单精度和双精度），这里简单列一下信息，
在类型相关小节还会详细说明：

|类型       |位数（字节数） |取值范围                                                           |
|-----------|---------------|-------------------------------------------------------------------|
|`float`    |32位（4字节）  |`-FLOAT_MAX`\~`-FLOAT_MIN`<br>`0.0`<br>`FLOAT_MIN`\~`FLOAT_MAX`      |
|`double`   |64位（8字节）  |`-DOUBLE_MAX`\~`-DOUBLE_MIN`<br>`0.0`<br>`DOUBLE_MIN`\~`DOUBLE_MAX`  |

如上表，浮点数都是有符号的，范围以0为中心左右对称，其中表示两种类型最大最小值的定义如下，这些定义在`__builtins`模块中，代码中可直接使用：

```
public final float  FLOAT_MIN   = 1.40129846432481707e-45F,
                    FLOAT_MAX   = 3.40282346638528860e+38F;
public final double DOUBLE_MIN  = 4.94065645841246544e-324,
                    DOUBLE_MAX  = 1.79769313486231470e+308;
```

浮点数字面量用于表示浮点数值，用十进制，从前往后可分为五个部分：
1. 整数部分，由数字组成  
*Note*：前导0没有任何数值之外的含义，即不会像整数字面量那样通过前缀指定进制
2. 小数点`.`
3. 小数部分，由数字组成
4. 指数部分，正则格式`[eE][+-]?\d+`，即以e或E开头，后面的数字指定以10为底的幂次，浮点数的值为前面三部分组成的小数值乘以10的幂
5. 浮点后缀，用`f`或`F`指定字面量是否为`float`类型

各部分必须连写，不能出现空白符，五个部分并不一定需要同时出现：
1. 若只含前三部分，则小数点必须出现，整数部分和小数部分至少出现其一，省略的部分按全0计算  
例：`1.0`、`3.14`、`02.78`、`.2`（0.2）、`100.`（100.0）等
2. 若含有指数部分且小数部分为0，则前面的底数（前三部分）也可只出现整数部分，省略小数点  
例：`1e100`（1×10<sup>100</sup>）、`.3e-9`（0.3×10<sup>-9</sup>）、`2.E+222`（2.0×10<sup>222</sup>）等
3. 如有`f`或`F`作为后缀，则字面量的类型为`float`，若省略则类型为`double`

浮点数字面量的值必须在对应类型的合法范围内，否则编译出错

### **nil字面量**

nil字面量用关键字`nil`表示非基础类型的nil值，nil字面量无类型，可直接赋值给任何非基础类型的变量，也可进行强制类型转换，例：

```
String s = nil;                     //普通类
int[] a = nil;                      //数组
Callable callee = nil;              //接口
Throwable t = cast<String>(nil);    //将String类型的nil赋值给Throwable接口，这和接口的nil值是不同的，参考接口语法的说明文档
```

### **字符串字面量**

Larva的字符串是由任意数量的字符构成的序列，由于字符定义是8位无符号整数，字符串实际就是字节串，不强制要求编码，任意字节序列都可以

字符串字面量分为两种形式，类型都为`String`

#### **普通字符串字面量**

普通字符串字面量用双引号`"`括起来，包含任意数量字符或字符的换码序列

1. 不可跨行，必须在一行内结束
1. 换码序列规则和字符字面量相同，参考字符字面量的说明

例：

```
"hello"
""
"\12xyz"
"\x01\x02\x03"
"\0\x00"
"你好"
```

#### **原始字符串字面量**

原始字符串字面量用反引号`` ` ``括起来，包含任意数量字符

1. 可跨多行，必须在本文件内结束
1. 字符串的内容就是反引号括起来的原始内容，不做任何转义，编译器的做法就是直接找下一个反引号作为结束符，这意味着内容中无法直接出现反引号
1. 如果字符串存在多行且某一行在换行之前有空白符，编译器会警告一下（因为这个小问题不太容易发现）

例：

```
`He said "hello"`

`这是一个
多行
字符串`

`hello 
world`  //上面hello后面有个空格，会警告提醒一下

`\x00`  //相当于普通字符串字面量"\\x00"
```

#### **字符串字面量的拼接**

Larva支持字符串字面量在词法分析阶段的拼接，如果代码中出现了多个连续的字符串字面量，则编译器会将其拼接起来作为一个字符串字面量

编译器会先将各字符串字面量分别解析完成，然后再直接拼接，因此普通字符串字面量和原始字符串字面量可以在拼接中混用

例：

```
a = "abc" "123";    //"abc123"
b = `\x00` "\t";    //"\\x00\t"
c = `hello ` `
world`;             //用拼接消除行尾空白的警告
d = "`" `\0` "`";   //由于不能直接在原始字符串中写反引号，可以用拼接实现
e = "\0" "00";      //需求是字符串包含\0和两个0，直接写\000会被解析为单个\0，分开拼接就好，当然也可以写"\00000"或"\x0000"，但拼接方式清晰一些
```

## **特殊词法**

### **Native代码**

Larva采用嵌入Go代码段的形式来实现Native代码开发，详细语法请参考‘5.Native代码开发’，这里只简单说明一下和词法相关的部分

规则：

1. 以标记`!<<`开始，`!>>`结束，两个标记之间的代码段为符合Native代码规范的Go代码

1. 开始结束标记必须独占一行，两侧可以有空白符

    *Note*：如果不独占一行，而是出现在其他代码中，则按正常代码解析，识别为`!`、`<<`和`>>`符号，导致语法错误

1. 对于Native代码内容，Larva并不做词法解析，只做特殊标记解析和处理（类似文本替换），详细规则请参考‘5.Native代码开发’

    *Note*：这意味着Native代码段中的Go的注释也会被输出到目标Go代码中，并且Native代码的正确性由开发者保证，若出现错误则会在`go build`阶段报错

例：

```
!<<
import "fmt"
!>>

class A
{
    !<<
    s string
    !>>
}

public void main()
{
    var a = new A();
    !<<
    //这行注释会被原样输出到目标Go代码中
    l_a.s = "hello"
    fmt.Println(l_a.s)
    !>>
}
```

### **编译控制命令**

编译控制命令的作用主要是控制编译过程，例如根据具体情况选择合适的代码段编译，主动报错等，详细语法请参考相关小节

规则：

1. 以符号`#`为一行的开头（前面可以有空白符），后面跟一个命令，再后面是必要的参数

1. `#`、命令和参数必须完整位于同一行中，不可跨行写，不可有跨行的块注释或原始字符串字面量

1. `#`和命令并不要求连写，可以插入适当空白符

1. 控制命令和其参数的语法自成一个体系，和正常Larva代码的关键字、标识符、语法无关

    *Note*：这意味着命令或命令的参数语法可以和关键字、标识符等重名，例如`#if`和关键字`if`

1. 控制代码块编译的控制命令（`#use`、`#if`等）可嵌套

1. 如果正常代码中出现`#`号，则看做非法符号，编译报错

例：

```
void f<T>(T t)
{
#if typein(T, {int, uint})
    println("T是int或uint");
#elif typeimplements(T, Callable)
    println("T实现了Callable接口");

# use
    t.f();
# oruse
    t.g();
# else
    #error "T没有方法‘f’或‘g’中的任意一个"
# enduse

#else
    #error "无效的T" //编译出错
#endif
}
```

*Note*：

1. 不强制要求风格，推荐尽量保证可读性，多级嵌套的时候可加入空行并对内层控制命令做适当缩进
（例如上面的内层`#use`风格是`#`号在行首，`#`和`use`之间缩进）
1. 只能用于语句列表中且不能跨越正常代码块，一般用于泛型类的方法和泛型函数中，不过在普通方法和函数中使用也是可以的，详细说明请参考相关小节
