# **词法元素**

本节用于说明Larva代码的各词法元素的规则

对于编译器来说，输入的源代码文件可看做是一个字符序列，第一步工作就是做词法分析，将文件内容分割为一个个“词”（后简称“token”），
本节说明的词法元素是指Larva的各类词法

## **词法分析规则**

1. **忽略间隔空白**

    词法元素之间的空白（制表符、空格、换行）将被忽略，即间隔的空白符不参与实际词法和语法，在词法分析过程中会被忽略，
    例如以下代码在词法上都是合法的：

    ```
    int i=1;
    int j      =         i +3;
    int
    k
    =
    -
    (
    i
    +
    j
    )
    ; //int k = -(i + j);拆成每行一个token
    ```

    *Note*：和大部分语言一样，Larva推荐用适当空格、空行分隔的方式来提高代码可读性

    *Note*：注意这里说的是“词法元素之间的间隔空白”，块注释和原始字符串等跨行的词法元素本身可以包含空白符的，并不会被忽略，
    但编译器也会考虑到代码的可读性，对原始字符串中的某些空白做适当警告，具体见字符串字面量小节

1. **最长子串原则**

    * **原则**

        Larva的词法分析遵循最长子串原则，即在分析一个token的时候，如果可能有多种选择，会从当前位置开始选择最长的一个合法选择，例如：

        ```
        //      //单行注释开始符是一个整体，不会被解析为两个除号
        /**/    //同上，块注释开始符不会被解析为除号和乘号
        ++a;    //对a做++自增，而不是两个+号
        123abc  //由于整数字面量允许后缀（见相关小节），这里不会被解析为123和abc两个词
        1.f();  //看上去是对“1”做方法调用，但由于浮点数支持省略尾数0，因此第一个词是“1.”
        a.123   //被解析为“a”和“.123”，因为浮点数可以省略前导0
        ```

        *Note*：上面这些例子只是作为最长子串原则的示例，其实大部分也都是语法错误，正常代码中不会出现

    * **特例**

        在有的语法设计下，最长子串原则可能会和人的习惯相悖，在Larva的泛型语法中存在一个特例：由于泛型类型实例化的语法是用尖括号“<>”，
        如果存在多层嵌套的话，右侧的“>>”按照最长子串原则将被解析为右移运算符，编译器在这里做了特殊处理，如果发现是嵌套的泛型类型实例，
        则将其视为两个“>”，由于泛型参数只可能是类型，不存在运算，因此不会出现歧义，例如：
        ```
        Iter<Iter<int>> it; //这里的“>>”被视为两个独立的“>”
        ```
        当然也可以将复杂的泛型实例分层写，提高可读性：
        ```
        Iter<
            Iter<int>
        > it;
        ```

## **注释**

Larva的注释分两种形式，除了注释说明外没有其他实质性的功能，但词法分析阶段只是简单将其丢弃掉

* **单行注释**

    单行注释以`//`开头，到所在行末尾，示例：

    ```
    int a = 0;  //这是一个单行注释
    int[] b = new int[]{
        1,  //插在跨行代码中的单行注释
        2,  //注释
    };
    ```

* **块注释**

    块注释以`/*`开头，`*/`结尾，可以跨行，例如：

    ```
    int a/*a的作用是……*/ = 123;
    /*
    b的作用是……
    */
    int b = 456;
    ```

* *Note*

    注释的解析是先分析开始标记，然后以当前行结束（单行注释时）或向前找到结束标记（块注释时），
    编译器不关心注释内容，因此块注释不能嵌套，只是简单扫描文件内容，找到结束标记`*/`

    字符串字面量的值是引号中的所有字符，不能直接在中间写注释，例如：

    ```
    String a = "hello /*这不是注释，是字符串的一部分*/world";
    String b = `hello //同上
    world`;
    ```

    这一点在Native代码的token中也是一样的

## **关键字**

Larva关键字（有的语言中也叫保留字）用于在代码中描述对应的语法，不可将其用作标识符

关键字列表：

```
from    import
class   interface
public  usemethod   final   ref
void    bool        schar   char    short       ushort  int     uint    long    ulong   float   double
foreach for         while   break   continue    if      else    return  defer
nil     true        false   this
var
new     cast
_
```

具体每个关键字的用法参考相关语法章节

*Note*：单下划线“\_”是一个关键字，这个会用在一些变量和值的特殊处理中，例如用于忽略某个值的输出等，这在Golang或Python等语言中也是一个惯例，
所不同的是在这些语言中“\_”在词法上是一个普通的标识符，而在语法上做了特殊处理，如Golang不允许将其作为值直接使用，Larva则采用更直接的方式，
将其作为关键字，杜绝了用其当变量的可能

*Note*：关键字的设计思路是尽量与现有语言接近，如果是多单词组合，则采用小写连写不加下划线分隔的方式，从风格上和变量名等做区别，
如“usemethod”、“foreach”等

## **标识符**

标识符用于类名、接口名、变量名、函数名、模块名等可自定义的名字，规则：

1. 格式：`[A-Za-z_][A-Za-z_0-9]*`，意即字母或下划线开头，由字母数字下划线组成
1. 不能和关键字相同
1. 长度无限制
1. 大小写敏感，例如`time`和`Time`是不同的名字
1. 普通标识符不能为内建宏的形式，即不能同时以双下划线开头和结尾，内建宏的说明见下
1. 不强制要求标识符命名规范和风格

*Note*：Larva的标识符风格建议（和Python较接近）：

* 类、接口名采用大写字母开头的驼峰形式，如“String”、“Callable”等
* `final`修饰的全局变量（初始化后不可修改，也可叫做常量）用下划线连接全大写词的形式，如“BUF_SIZE”等
* 变量、函数名采用下划线连接全小写词的snake形式，如“recved_len”、“make_pair”等
* 模块名风格基本和变量和函数名风格相同，但标准库的第一级模块例外  
*Note*：标准库第一级模块强制要求不能有常规下划线，见“2.2.程序结构”中关于模块组织的限制说明，这个只需要开发语言的人注意一下就好，
普通开发者无需关心
* 如果一个名字是用于比较“私有”的功能或非正式功能，可用单下划线开头

### **内建宏**

内建宏是指同时以双下划线作为开头和结尾的特殊标识符，这些宏会在词法分析阶段由编译器做替换，
主要功能是能将一些编译环境、代码上下文的信息直接插入代码中

目前支持的内建宏有：

|内建宏             |类型       |说明                                                                                  |
|-------------------|-----------|--------------------------------------------------------------------------------------|
|`__PLATFORM__`     |`String`   |编译环境的平台全名，例如“Linux-2.6.32-754.el6.x86_64-x86_64-with-centos-6.10-Final”   |
|`__MACHINE__`      |`String`   |编译环境的机器硬件名，例如“x86_64”                                                    |
|`__SYSTEM__`       |`String`   |编译环境的系统名，例如“Linux”                                                         |
|`__MODULE__`       |`String`   |当前模块名，例如“os/path”                                                             |
|`__FILE__`         |`String`   |当前源代码文件名，一般为绝对路径形式                                                  |
|`__LINE__`         |`int`      |当前行在文件中的行号（从1开始）                                                       |
|`__TIMESTAMP__`    |`long`     |执行编译的Unix时间戳，精确到毫秒                                                      |

如果代码中出现了不能识别的内建宏，则编译报错

*Note*：内建宏的初衷是将编译环境信息插入代码，这样编译出来的程序就可支持类似`version`选项来查看编译来源之类
（比如还可加上git commit hash之类的信息），不过更好的办法似乎是用编译脚本来管理，采用生成信息代码的方式

## **符号**

Larva中的符号主要起到分隔、运算和标记等作用

### **普通符号**

普通符号在词法分析的时候，都作为一个独立的token，主要起到分隔符和运算符的功能

Larva的普通符号包括：

```
.       ..
(       )       [       ]       {       }       :       ;       ,
~       !       +       -       *       /       %       &       |       ^       <<      >>
<       >       !=      ==      !==     ===     <=      >=      &&      ||
=       +=      -=      *=      /=      %=      &=      |=      ^=      <<=     >>=     ++      --
```

各符号在不同语法中可能有不同的含义，在具体的语法说明中会提到，这里只是从词法元素的角度将其罗列出来

### **标记符号**

标记符号和普通符号不同，它们不是单独的token，而是对一个复杂token进行标记，主要有以下几种：

1. 字符、字符串字面量的引号：`'`、`"`、`` ` ``
1. 注释的开始和结束标记：`//`、`/*`、`*/`
1. Native代码的开始和结束标记：`!<<`、`!>>`
1. 编译控制命令的开始标记：`#`

*Note*：Native代码和编译控制命令的标记对于格式有一定要求，见本文下面的‘特殊词法’一节

## **字面量**

字面量是一大类token，用于在代码中表示固定值，类似“立即数”的概念

*Note*：有些文章或书中字面量（literal）也被称为常量（constant），本文档会尽量区分这两种的含义，
“常量”更多指一个不可修改的（如final修饰）变量这种被命名的东东

### **布尔型字面量**

布尔型值只有真假两个，字面量用`true`和`false`两个关键字表示，类型为`bool`

### **字符字面量**

Larva中的“字符”是指0~255范围的单字节，类似组成Python2的字符串的字符，或Go的byte概念

字符字面量是指用单引号括起来的，单个字符或单个字符的换码序列（转义）的token，例如：

```
'a'     '\0'    '\177'  '\xef'
```

#### **换码序列**

换码序列用于在字符字面量或普通字符串字面量中对字符进行转义表示，一般用于无法表示或不方便表示的字符

换码序列表：

|换码序列                   |说明                                           |
|---------------------------|-----------------------------------------------|
|`\\`                       |反斜杠`\`                                      |
|`\'`                       |单引号`'`                                      |
|`\"`                       |双引号`"`                                      |
|`\a`                       |响铃，即`'\x07'`                               |
|`\b`                       |退格，即`'\x08'`                               |
|`\f`                       |换页，即`'\x0C'`                               |
|`\n`                       |换行符                                         |
|`\r`                       |回车符                                         |
|`\t`                       |水平制表符                                     |
|`\v`                       |垂直制表符，即`'\x0B'`                         |
|`\d`<br>`\dd`<br>`\ddd`    |用1到3位的八进制数字（0~7）表示对应号码的字符  |
|`\xHH`                     |用2位十六进制数字（0~F）表示对应号码的字符     |

换码序列规则说明：

1. 在字符字面量或普通字符串字面量中以`\`开头，符合上述形式，如`\`后的代码不符合规则则编译报错
1. 单双引号的转义主要是为了和字面量的开始结束标记区分，如果标记不同也可不用转义，例如字符串中的单引号`"'"`，双引号字符字面量`'"'`
1. 八进制换码序列可由1到3个数字组成，编译器会在这个范围内选择最长的合法八进制数，再根据其值确定表示的字符，例：
    1. `'\128'`中的内容被解析为`'\12'`和`'8'`，由于是两个字符，因此不是合法的字符字面量
    1. `'\432'`中的内容被解析为编号为八进制的“432”的字符，即282号字符，这个范围已经超出0~255了，因此也不是合法的字符字面量
1. 十六进制换码序列的形式是固定为2位十六进制数字，数字不区分大小写，一般推荐用大写

### **整数字面量**

### **浮点数字面量**

### **nil字面量**

### **字符串字面量**

## **特殊词法**

### **Native代码**

Larva采用嵌入Go代码段的形式来实现Native代码开发，详细语法请参考‘5.Native代码开发’，这里只简单说明一下和词法相关的部分

规则：

1. 以标记`!<<`开始，`!>>`结束，两个标记之间的代码段为符合Native代码规范的Go代码

1. 开始结束标记必须独占一行，两侧可以有空白符

    *Note*：如果不独占一行，而是出现在其他代码中，则按正常代码解析，识别为`!`、`<<`和`>>`符号，导致语法错误

1. 对于Native代码内容，Larva并不做词法解析，只做特殊标记解析和处理（类似文本替换），详细规则请参考‘5.Native代码开发’

    *Note*：这意味着Native代码段中的Go的注释也会被输出到目标Go代码中，并且Native代码的正确性由开发者保证，若出现错误则会在`go build`阶段报错

例：

```
!<<
import "fmt"
!>>

class A
{
    !<<
    s string
    !>>
}

public void main()
{
    var a = new A();
    !<<
    //这行注释会被原样输出到目标Go代码中
    l_a.s = "hello"
    fmt.Println(l_a.s)
    !>>
}
```

### **编译控制命令**

编译控制命令的作用主要是控制编译过程，例如根据具体情况选择合适的代码段编译，主动报错等，详细语法请参考相关小节

规则：

1. 以符号`#`为一行的开头（前面可以有空白符），后面跟一个命令，再后面是必要的参数

1. `#`、命令和参数必须完整位于同一行中，不可跨行写，不可有跨行的块注释或原始字符串字面量

1. `#`和命令并不要求连写，可以插入适当空白符

1. 控制命令和其参数的语法自成一个体系，和正常Larva代码的关键字、标识符、语法无关

    *Note*：这意味着命令或命令的参数语法可以和关键字、标识符等重名，例如`#if`和关键字`if`

1. 控制代码块编译的控制命令（`#use`、`#if`等）可嵌套

1. 如果正常代码中出现`#`号，则看做非法符号，编译报错

例：

```
void f<T>(T t)
{
#if typein(T, {int, uint})
    println("T是int或uint");
#elif typeimplements(T, Callable)
    println("T实现了Callable接口");

# use
    t.f();
# oruse
    t.g();
# else
    #error "T没有方法‘f’或‘g’中的任意一个"
# enduse

#else
    #error "无效的T" //编译出错
#endif
}
```

*Note*：

1. 不强制要求风格，推荐尽量保证可读性，多级嵌套的时候可加入空行并对内层控制命令做适当缩进
（例如上面的内层`#use`风格是`#`号在行首，`#`和`use`之间缩进）
1. 只能用于语句列表中且不能跨越正常代码块，一般用于泛型类的方法和泛型函数中，不过在普通方法和函数中使用也是可以的，详细说明请参考相关小节
