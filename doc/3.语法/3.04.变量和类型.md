# **变量和类型**

本节说明Larva的变量、数据类型和类型相关的操作规则

## **概述**

作为一个命令式的语言（和声明式、函数式等相对），Larva代码就是用语法规则描述处理数据的过程，Larva中的数据通过变量来存储或引用，
变量和数据都有自己的类型，类型则决定了它的值集合拥有统一的方法和行为，这一点和主流的C++、Java、Golang等都是一样的

*Note*：Larva没有明确的“常量”（constant）的概念，而是用`final`修饰全局变量，使其在初始化后不可再赋值来实现，这只是Larva语法上的约束，
和其他一些语言的常量在实现和行为上会有一些差别，后面的文档中涉及到Larva的“常量”都是指`final`修饰的全局变量，而有时也会根据上下文用“变量”来描述

## **变量**

### **变量的定义**

Larva的变量分为全局变量和局部变量两种，本节只简单描述变量的概念和定义、使用的语法，便于类型系统和之后的文档说明，
具体到变量相关的语法规则在后面的相关章节再详细说明

1. 全局变量

    全局变量的定义在代码文件的全局区域（即不在类、接口或函数内部），详细说明请跳转‘3.9.全局变量’一节

1. 局部变量

    局部变量定义在函数或方法内部（包括参数），可有多种形式

    1. 形参域的定义格式：`[ref] 类型 变量名`

        函数或方法的参数也是局部变量，在形参域中定义，必须指定类型，可通过关键字`ref`指定是否通过别名引用传递参数，详细说明参考函数相关章节

        例：
        ```
        void f(int a, ref double b)
        {
            //函数的语句块
        }
        ```

    1. 通过类型定义，格式：`类型 变量名 [= 初始化表达式][, 变量名 [= 初始化表达式]]...[,];`

        这个语法格式除了没有修饰外，和全局变量的定义格式、规则相同，用于单独的变量定义语句或`for`语句的第一域

        例：
        ```
        void f()
        {
            int a = 123, b; //没有赋初值的b的值为int类型的零值，即0
            long
                c = 1,
                d = 2,
            ;               //多行定义如果想代码整齐一些可以这样，在增加变量的时候代码diff也相对清晰一些
            for (int i = 0, j = 10; i < 8 && j > 3; ++ i, -- j)
            {
            }
        }
        ```

    1. 通过关键字`var`定义，格式：`var 变量名 = 初始化表达式[, 变量名 = 初始化表达式]...[,];`

        * 不指定类型，但必须指定初始化表达式，通过表达式的类型来推导出变量的类型
        * 每个变量的类型由自己的初始化表达式确定，意即如果定义多个变量，它们的类型可以不同
        * 初始化表达式必须有一个确定的数据类型，不能是无类型的`nil`或无返回值（返回类型为`void`）的函数调用
        * 用于单独的变量定义语句或`for`语句的第一域

        例：
        ```
        void f()
        {
            var a = 1, b = new int[10], c = "hello"; //类型：a是int，b是int[]，c是String
            for (var i = 0, j = ""; i < 100 && j.len() < 100; ++ i, j = j.concat("%d".(i)))
            {
            }
        }
        ```

    1. `foreach`语句有自己的规定，循环变量强制定义，且格式固定：`foreach ({var ¦ 类型} 变量名 : 迭代器表达式)`

        例：
        ```
        void f()
        {
            foreach (int i: new int[]{1,2,3}.iter())
            {
                println(i);
            }
            foreach (var p: new Pair<int, String>[]{
                2: "hello",
                7: "hi",
            }.iter())
            {
                println("%d:%s".(p.first(), p.second()));
            }
        }
        ```

### **变量的使用**

变量的使用比较简单，直接在其作用域范围内用名字存取即可

被导入的模块的全局变量采用`模块名.全局变量名`来存取

全局变量如被`final`修饰，则不可做赋值操作

例：
```
import x;

final int A = 0x1;
int a = 123;

void f(int b)
{
    int c = b + 1;  //存取局部变量b和c
    a += c * 2;     //存取全局变量a
    x.a -= a;       //假设模块x有一个全局变量“public int a”，用其和本模块的a做计算来更新它
}

void g()
{
    println(A); //正常打印A的值
    A = 456;    //错误，A是final的，不可赋值修改
    ++ A;       //错误，自增自减和增量赋值都算是赋值，不可以进行
}

```

## **类型**

### **概述**

#### **语法**

Larva的类型在语法中的表示可分为三个部分：
1. 名字，基础类型用关键字，类和接口则根据名字查找规则用其名字或`模块名.类或接口名`的形式
2. 如第一部分是泛型类或泛型接口，则需要提供正确数量的泛型参数，用尖括号括起来，泛型参数中的每个类型语法同本规则
（当然可以嵌套泛型实例，也可以用数组）
3. 如果类型是数组，则根据数组维度在末尾用多个方括号对`[]`来指定

例：
```
int                         //基础类型int
String                      //字符串类
Throwable                   //可作为异常抛出的接口
fiber.Worker                //fiber模块的Worker类
long[][]                    //基础类型long的二维数组类型
util.Vector<Iter<double[]>> //以基础类型double的数组的迭代器接口为元素类型的util.Vector类
```

#### **基础类型**

基础类型包括：

|类型       |位数（字节数） |说明               |取值范围                                                               |
|-----------|---------------|-------------------|-----------------------------------------------------------------------|
|`bool`     |8位（1字节）   |布尔型             |`true`、`false`                                                        |
|`schar`    |8位（1字节）   |有符号字符型       |`-128`~`127`                                                           |
|`char`     |8位（1字节）   |无符号字型符       |`0`~`255`                                                              |
|`short`    |16位（2字节）  |有符号短整型       |`-32768`~`32767`                                                       |
|`ushort`   |16位（2字节）  |无符号短整型       |`0`~`65535`                                                            |
|`int`      |32位（4字节）  |有符号整型         |`-2147483648`~`2147483647`                                             |
|`uint`     |32位（4字节）  |无符号整型         |`0`~`4294967295`                                                       |
|`long`     |64位（8字节）  |有符号长整型       |`-9223372036854775808`~`9223372036854775807`                           |
|`ulong`    |64位（8字节）  |无符号长整型       |`0`~`18446744073709551615`                                             |
|`float`    |32位（4字节）  |单精度浮点数类型   |`-FLOAT_MAX`\~`-FLOAT_MIN`<br>`±0.0`<br>`FLOAT_MIN`\~`FLOAT_MAX`       |
|`double`   |64位（8字节）  |双精度浮点数类型   |`-DOUBLE_MAX`\~`-DOUBLE_MIN`<br>`±0.0`<br>`DOUBLE_MIN`\~`DOUBLE_MAX`   |

表中两种浮点数类型最大最小值是：

|常量           |值（十进制）               |值（十六进制）             |
|---------------|---------------------------|---------------------------|
|`FLOAT_MIN`    |`1.1754943508222875e-38`   |`0x1p-126`                 |
|`FLOAT_MAX`    |`3.4028234663852886e+38`   |`0x1.FFFFFEp127`           |
|`DOUBLE_MIN`   |`2.2250738585072014e-308`  |`0x1p-1022`                |
|`DOUBLE_MAX`   |`1.7976931348623157e+308`  |`0x1.FFFFFFFFFFFFFp1023`   |

注：这个范围只是IEEE-754标准的正规数表示范围，标准还规定了比`FLOAT_MIN`和`DOUBLE_MIN`更小的非正规形式浮点数，以及`inf`、`nan`等表示方式，
具体可参考标准文档

浮点数的零值有正负之分，虽然值一样，在计算中是一样的，大部分计算过程也会自动将`-0.0`转为`0.0`，但二进制表示是不同的，
比如在做浮点数hash值的时候就可能需要注意这个问题

除`bool`外的其他基础类型后续称为**数值类型**，数值类型的最大最小值以常量的形式定义在`__builtins`模块中，可参考标准库相关文档

基础类型都是值类型：
1. 赋值操作（包括非`ref`参数传递等）都是传递值
1. 赋值给接口的时候也是拷贝一份值让接口引用

#### **类**

Larva中可以用`class`关键字自定义类型（这里的描述包括泛型类），一个类可看做是带方法的结构体，和其他主流OOP语言的类概念类似

**名词定义**：通过类构建的数据称为**实例对象**，Larva中的数据包括基础类型的值和类的实例，
在后面也会根据具体上下文将二者统称为**对象**（因为从接口的角度看，接口也可以引用基础类型的值）

Larva的类是句柄引用类型，即一个类型为类的变量是这个类的对象实例的句柄，引用对象实例或为`nil`值，例：
```
public void main()
{
    var a = new int[]{123}; //变量a引用了一个数组对象
    var b = a;              //变量b引用了a引用的对象，即a和b引用同一个对象
    b[0] = 456;             //通过b改变对象的内容
    println(a[0]);          //可看到a引用的对象内容是被改变了

    String s;               //s默认为nil，没有引用任何字符串对象
    println(s);             //会由于空指针而crash
}
```
Larva的这个特性和Python、Java的对象引用是一个概念，也可以类比为C++和Go的对象的指针来理解，后面我们用类的“值”来表示其“指针值”的概念

类的`nil`值也可直接调用其方法，这种情况下在方法中`this`为`nil`，例：
```
class A
{
    void f()
    {
        if (this === nil)
        {
            println("通过类的nil值调用方法");
        }
        else
        {
            println("通过类的正常实例调用方法");
        }
    }

    int a;
}

public void main()
{
    cast<A>(nil).f();
    new A().f();
}
```
当然，如果在这个例子的方法`f`中，当`this`为`nil`的时候通过`this.a`存取属性，就会崩溃

*Note*：
* Larva的数组本质上也是一个类，实际上是泛型类`__array.Arr<E>`的具体实例，所以说Larva的数据类型只有基础类型和类

* 注意Larva的String也是一个类，而不是基础类型，这跟Go不同，跟Java类似，所以String类型也有nil值

* 空指针的访问会导致程序崩溃，而不是一个常规错误或异常，参考‘3.5.程序执行’的错误处理相关内容

* 实际上如果将基础类型看做是不可变的对象，也能在逻辑上像Python一样统一为“一切数据和变量皆对象和句柄引用”

* 大部分语言一般只用“引用”这个词，但引用也分为上述的句柄引用和类似C++引用的“别名引用”，在形式上有区别，Larva二者都有，
因此文档中一般不会单独用“引用”这个词

类的其它内容，如定义、使用等，在后面类的小节专门说明

#### **接口**

基础类型和类是Larva数据类型的两类，Larva在定义变量的时候还可以使用接口类型

* 接口不是具体的数据类型，只能是变量类型或表达式计算结果的类型

    例：
    ```
    public void main()
    {
        Any a;                  //变量a的类型为Any接口
        var b = cast<Any>(123); //将int数值转为Any类型，表达式结果类型为Any，因此b也是Any接口类型的变量
    }
    ```

    *Note*：由于表达式计算结果可以看做是一个存储结果的临时变量，下面都用变量引用的形式描述

* 接口有自己的方法集合，一个接口的变量只能引用实现了它的方法集合的对象，方法签名必须完全匹配，详细说明可参考接口相关章节

* 只有不含任何方法的接口（如内建接口`Any`）才可以引用基础类型的值，因为基础类型没有方法

    *Note*：自定义的无任何方法的接口也可以引用基础类型的值，但一般也都是直接用`Any`，为方便起见下面都简称为“Any接口”

* 接口类型的值由类型信息和对象引用两部分组成，要么是nil，要么引用了一个基础类型的右值，或类的对象实例，或类的nil值，
后面我们用接口的“值”来表示其保存的“类型信息+对象引用”的组合概念
    * 若接口值为nil，说明其未引用任何对象，此时其对象引用部分无意义，也不能调用接口的任何方法
    * 若接口引用了一个类的nil值，则接口存在类型信息，对象引用部分为nil，此时调用接口方法相当于以对应类的nil值来调用方法
    * 其余情况则是接口引用了一个基础类型的值（只能是Any接口）或类的对象实例

    例：
    ```
    class A
    {
        public String str()
        {
            return "A.str()";
        }
    }

    public void main()
    {
        //Throwable是内建模块的一个接口，有一个public String str()方法
        Throwable t;        //默认为nil
        Any a = t;          //a也是nil
        t = "error";        //t引用了一个字符串
        a = t;              //a和t引用了同一个字符串
        a = 123;            //a改为引用了一个int值
        println(t.str());   //字符串的str方法返回自身，输出“error”
        t = cast<A>(nil);   //引用一个类的nil值
        println(t.str());   //以类A的nil值调用str方法，输出“A.str()”
        t = nil;
        t.str();            //对接口nil值调用任何方法都会崩溃
    }
    ```

* 内建模块有一个接口`GoAny`，其定义形式和`Any`一样，都是无方法的接口，但它和Larva的类型系统在语法上是隔离的，
即不能将Larva的对象赋值给GoAny的变量，GoAny的主要用处是引用非Larva的数据，即Golang层面的各种对象

*Note*：接口类型实际就是Go的接口的直接使用，上面的规则也可直接对照Go的接口来理解

接口的其它内容，如定义、使用等，在后面接口的小节专门说明

#### **数组**

Larva支持在语法上定义数组类型，如前面语法小节所述，数组的定义就是在一个类型后面加若干个方括号`[]`，来表示此类型的N维数组，数组是一个特殊的类，
从实现上来说它是用`__array.Arr<E>`这个泛型类来实现的，因此它除了类型名比较特殊以及拥有自己的下标运算等规则外，具有类类型的各种特性

数组的元素是它的元素类型的值，即：
1. 基础类型保存值
1. 类类型保存对对象实例的引用，或类的`nil`值
1. 接口类型保存接口本身的值

因此，多维数组的第一维元素类型是次一维的数组，例如：`int[][][]`的元素类型是`int[][]`（的引用），这意味着多维数组只是一种通俗的说法，
本质是一维数组，各元素之间是互相独立的，例：
```
public void main()
{
    var a = new int[][]{
        {1, 2, 3},
        {4, 5},
        nil,
    };
    println(a[0].size()); //3
    println(a[1].size()); //2
    println(a[2].size()); //存取类的nil值，崩溃
}
```
如示例所示，二维数组的元素是一维数组，每个一维数组都可以有自己的值

数组在创建时需指定大小（元素数量），一个数组的元素数量固定，创建数组的语法请参考表达式一节

*Note*：元素数量固定是指不能在不修改引用的前提下直接改动大小，和下面说的数组切片是两回事

数组元素的存取一般使用下标运算符`[]`来进行，规则：
1. 下标值可用所有八种整数类型
1. 下标范围必须在[0, size)之间，其中size是数组大小（所含元素个数），否则程序崩溃
1. 下标运算的结果是一个左值，即可以赋值

例：
```
public void main()
{
    var a = new int[10];
    a[0] = 123;
    a[1] = a[0] + 456;
    a[0] *= a[1];
    println(a[0]);
    println(a[100]); //崩溃
}
```

数组支持切片操作，切片操作格式是在运算符`[:]`中指定开始和结束下标，表示一个左闭右开的范围，例如`a[1 : 4]`返回数组a的一个切片，
映射a的下标范围[1,4)

切片规则：
1. 切片运算返回的类型依然是数组类型
1. 切片结果是对原数组（或原数组映射的数组）的指定范围的映射，二者共享存储空间
1. 切片运算的开始和结束下标必须在被映射的原始数组的大小范围内，且结束下标不得小于开始下标，否则程序崩溃
1. 若开始下标为0，或结束下标为数组的大小，则可省略

需要注意的是一个数组的切片、以及切片的切片都引用同一个数组元素的存储空间，它们在语法上也都是数组类型

例：
```
public void main()
{
    var a = new int[]{1, 2, 3, 4, 5};

    var b = a[: 3];
    println(b);     //输出“<int[] [1, 2, 3]>”
    var c = b[1 :];
    println(c);     //输出“<int[] [2, 3]>”
    var d = c[: 3]; //结束下标超出c的范围了，但是没有超出引用的实际数组区域的范围，合法
    println(d);     //输出“<int[] [2, 3, 4]>”

    d[1] = 100;
    println("%d %d %d %d".(a[2], b[2], c[1], d[1]));    //输出4个“100”，因为都引用同一个数组空间

    d = new int[10];
    //d引用了一个新的数组，因此后面再修改d的话就对上面a、b、c引用的数组无影响了
}
```

*Note*：如果觉得概念有点绕，不妨这样理解：创建数组的本质是先创建一块空间，然后创建一个数组对象，引用这个空间的全范围切片，
例如用伪代码描述，`new int[10]`其实是`MAKE_ARRAY(int[], 10)[:]`，即所有数组都是对对应空间的切片引用，可以多数组引用同一个空间，
只是通俗地称为数组罢了

作为一个类，数组还有自己的方法，具体说明请参考`4.1.__array`

#### **闭包**

Larva支持闭包，即函数或方法中定义函数，并绑定外层函数或方法的局部变量空间，由于Larva并不直接支持函数类型，因此闭包是用匿名类的对象来实现的，
也就是说闭包类型本身也是一种特殊的类

闭包是一个表达式，以方括号对`[]`开头，后面跟着用花括号`{}`括起来的多个函数定义，组成一个匿名类的对象实例，定义的函数即此对象实例的方法，
和一般类不同的是，这个匿名类没有属性，只有一些方法集合，并且不能用`this`来引用自身的其他方法，闭包中的`this`将被看做是外层方法所属对象的`this`，
由于闭包类型是匿名类，其类型不能直接写出，一般的做法是将其赋值或类型转换为一个接口，当然闭包的方法签名必须符合对应接口

例：
```
interface I
{
    void f();
    public void g();
}

class A
{
    I make_closure()
    {
        int x = 123;
        return []{
            void f()
            {
                println(x); //输出闭包环境下的上层局部变量x的值
            }

            public void g()
            {
                println(this.a);    //输出所在方法所属的对象的属性值
            }
        };
    }

    int a;
}

public void main()
{
    var a = new A{a: 456};
    var i = a.make_closure();
    i.f(); //输出“123”
    i.g(); //输出“456”
}
```

虽然无法直接用语法写出闭包的类型，但闭包是有内部类型的，类型名为`模块名.closure_编号`，在编译错误提示中可能会看到

可以直接用`var`使得变量类型推导为闭包类型，进一步还可以通过泛型函数的类型推导获取到闭包类型，例：
```
void test_closure<T>(T t)
{
    //main中的代码将c传入后，T被推导为c的闭包类型
    t.f();

    //可以直接定义T的变量，但是无法直接赋值为其他闭包，只能为同类型的值或nil
    T x = t;
    x.f();
    x = nil;
    x.f();      //值为nil的闭包对象实例调用方法会导致程序崩溃
}

public void main()
{
    //c的类型就是闭包类型本身
    var c = []{
        void f()
        {
            println("closure_of_main.f");
        }
    };
    test_closure(c); //无法显式指定泛型参数为闭包类型，但可以通过类型推导
}
```

为方便起见，如果闭包只有一个签名为`public void call()`的方法，也可采用简写的方式：`[-]`开头，后面花括号中直接写语句，
内建库的`Callable`接口可接受有这个方法的对象实例，例：
```
public void main()
{
    //下面c1和c2的定义和使用在语法上是等价的

    Callable c1 = []{
        public void call()
        {
            println("call");
        }
    };
    c1.call();

    Callable c2 = [-]{
        println("call");
    };
    c2.call();
}
```

闭包只能出现在函数或方法中，不能出现在全局位置

### **零值**

每个类型都有自己的零值，一般是在各种场景下用于类型变量的默认值、缺省值等，零值表：

|类型       |零值                   |
|-----------|-----------------------|
|`bool`     |`false`                |
|整数类型   |对应类型的数值`0`      |
|浮点数类型 |对应类型的数值`0.0`    |
|类         |对应类的`nil`值        |
|接口       |对应接口的`nil`值      |

也可调用内建泛型函数`zero_value<T>()`返回类型`T`的零值

### **类型转换**

Larva的变量、表达式在进行赋值、运算的时候，若类型和需求不符，可能会需要进行类型转换，即将一种类型的变量或结果转换成另一种的值：
1. 赋值（包括传参）操作需要赋值的表达式和被赋值的左值类型一致，若不一致则需要将表达式转换为和左值类型一致的结果
1. 做各种运算的时候，运算分量的类型需要符合具体运算规则的要求，详细的运算规则可参考表达式相关章节

本节主要说明类型转换的形式和方法，主要有三种形式

#### **隐式转换**

隐式转换是指不需要用额外的转换语法或函数，由编译器自动识别并处理的类型转换，Larva的设计原则之一是尽量强类型，因此隐式转换的情形并不多

隐式转换规则包括以下几条：

1. 无类型的`nil`值（即nil字面量）可以转为任何类或接口类型的`nil`值

    例：
    ```
    String s = nil;
    Callable c = nil;
    ```

1. 任何类型都可转为无方法的接口（nil字面量赋值为接口的nil值，int字面量视为`int`类型）

    例：
    ```
    void f()
    {
        Any a = nil;
        a = 123;
        a = 0.0;
        a = true;
        a = "hello";
        a = [-]{};
    }
    ```

1. 若目标类型是接口，原始值的类型是类或接口且实现了目标类型接口的所有方法（即实现了目标接口），则可隐式转换

    需要注意：是原始值的“类型”实现了目标接口，而不是原始值的“对象”实现了目标接口

    例：
    ```
    void f()
    {
        Throwable t = "error";  //String实现了Throwable接口，可直接赋值
        Any a = t;              //Throwable“实现”了Any接口，可直接赋值
        t = a;                  //错误，虽然a引用的是String对象实例，String实现了Throwable，
                                //但是隐式转换看的是原始值类型而非原始值的实际对象，Any没有“实现”Throwable接口
    }
    ```

    *Note*：说一个接口“实现”另一个接口其实是不严谨的，严格的说法应该是“实现了A接口的对象必然实现了B接口”

1. int字面量在值符合范围的情形下，可以转为目标数值类型，如此规定主要还是为了编码的方便性，因为如果规定int字面量就是int，
不能直接赋值给其他数值类型的话，代码会比较繁琐

    注意：只有“int字面量”符合这个条件，如果对字面量做了任何运算，则int字面量将确定为int类型数据参与计算，包括取正取负操作

    例：
    ```
    //正确的代码
    char c = 200;
    short s = 0x7FED;
    ushort us = 0xFFFF;
    double d = 123;

    //错误的代码
    schar sc = -1;          //1是int字面量，取负运算后确定为int类型的结果，不能赋值给schar
    float f = cast<int>(1); //类型转换后结果为int类型，不能赋值给float
    ```

    *Note*：对int字面量取负后也失去了隐式转换的规则，或者说负数不算字面量而是表达式，这个规定是有些不太近人情，不过要做的话改动也比较大

*Note*：int字面量和nil字面量在赋值目标或转换目标类型确定的情形下可以被转换，但如果目标类型不确定，或者不是很明确地确定的时候，
可能会要求强制转换类型，例如`var`定义变量时的类型推导、泛型函数的类型推导、三目运算符`if-else`等场景，如果不注意，编译器可能会报类型相关错误

#### **强制转换**

Larva提供了`cast`关键字，可以显式进行类型转换，语法格式类似泛型：`cast<目标类型>(表达式)`

例：`cast<double>(123L)`将`long`类型的字面量转换为`double`类型

`cast`类型强转规则：

1. 若符合隐式转换的规则，则也能使用强制转换，行为和隐式转换相同

    例：
    ```
    var a = cast<String>(nil);  //将nil字面量强制转换为String类型的nil值
    Any b = cast<Any>(123);
    ```

1. 不同数值类型之间可以进行强制转换，转换的行为和Go中数值类型的转换相同：
    1. 若为整数类型之间的转换，则原始值先做符号扩展，然后根据目标类型的位数进行末位截取
    1. 若为浮点数转为整数，则丢弃小数部分（向零取整）
    1. 若目标类型为浮点数，则转换后的数值根据目标类型的精度做必要的舍入
    1. 凡是涉及浮点数类型的转换，如果目标类型的值域范围内无法表示原始值，则转换会成功但是最终结果和平台相关

#### **类型断言**

类型断言是对于一个类型为接口的变量或接口的值，断言其引用的对象为目标类型，目标类型可以是某种类型或另一接口，并求得对应的目标类型的值

类型断言可能成功也可能失败，Larva用内建函数的形式提供类型断言功能，即内建库的函数`try_assert_type`和`assert_type`，是两个泛型函数：

```
/*
断言a引用的对象为类型T（若T是基础类型或类）或能隐式转为T（若T是接口）
成功则返回true，t的值被设置为断言结果
失败则返回false
如输入接口的nil值，则失败（接口nil值表示没有引用任何对象）
*/
public bool try_assert_type<T>(Any a, ref T t)

/*
功能同try_assert_type，成功返回断言结果，失败抛出TypeAssertionError异常
*/
public T assert_type<T>(Any a);
```

例：

```
public void main()
{
    Any a = "hello";
    var s = assert_type<String>(a);
    Throwable t;
    println(try_assert_type(a, ref t)); //输出true
    println(s === t);                   //输出true
}
```

*Note*：从函数签名来看，由于被断言的参数是`Any`，所以传任何值都是可以的，且目标类型也可以是输入值可直接隐式转换的，
这也意味着`assert_type<long>(1L)`、`assert_type<Any>("")`之类的代码也没有任何错误，不过这么做显然没什么意义，所以从功能需求角度说，
类型断言一般用法还是对于接口类型的值断言其是某类型的对象，或实现了某接口
