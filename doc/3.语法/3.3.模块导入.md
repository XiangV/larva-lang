# **模块导入**

本节用于说明Larva的模块导入语法和规则

## **概述和定义**

模块分类、定义等内容请参考前述‘2.2.程序结构’中的相关内容

这里重复一下**模块全名**和**模块名**的定义：**模块全名**指一个模块的完整名字，而**模块名**来指模块全名中的最后一级名字

## **规则**

1. Larva的模块代码中如果要引用其他模块的元素（public的类、接口、函数、全局变量等），必须在对应的代码文件中指定导入被引用的模块
1. 导入模块的语句必须在代码文件开头处（当然前面可以有注释和空白）
1. 每个文件导入的模块只属于自己，即同一模块的多个代码文件需要分别导入自己所需的依赖模块
1. 模块之间不可产生循环依赖，否则编译报错
1. 只能导入自己可见的模块，即不能导入无法访问的私有模块，私有模块的说明见下
1. 导入的多个模块的模块名不能重复，如存在重复名字，可使用别名来规避

### **私有模块**

模块名以双下划线开头的模块是私有模块，私有模块及其下的非私有下级模块只允许其上一级模块和上一级模块下的所有下级模块导入，例如：

* `a/b/__c`允许被`a/b`及其所有下级模块的代码导入并使用
* `a/b/__c/__d`不允许被`a/b`导入，只允许被`a/b/__c`及其所有下级模块导入

## **语法**

### **直接import方式**

可以直接用`import`关键字导入模块，可在一条语句中导入多个模块

格式：`import <导入模块描述>[:<别名>][, <导入模块描述>[:<别名>]]...;`，即可以用逗号分隔每个导入的模块

导入模块描述分为两种形式：

1. **通过全名描述**

    例：
    ```
    import os, util/iters;
    import math/rand: rd;           //通过别名简化代码中的使用
    import "github.com/a/b"/x/y,
           "github.com/c/d"/y: d_y; //通过别名与"github.com/a/b"/x/y区分开
    ```

1. **通过模块相对位置描述**

    `import`支持相对位置导入模块，若要导入的模块和当前模块有一定逻辑关系，则一般采用这种形式

    描述格式：`{./|../[../]...}<模块名>[/<模块名>]...`
    1. 若以`./`开头，则表示相对于当前模块的下级模块
    1. 若以N个`../`开头，则表示当前模块的N级上级模块下的下级模块
    1. `./`和`../`只能出现在开头，`./`只能出现一次，且二者不能混用
    1. 通过`../`方式导入的时候，上级模块层数不能超过当前模块的层数，且不能跨越标准库和用户库

    *Note*：一般来说采用相对位置导入的模块和导入者之间都存在一定程度的逻辑关系，如果没有比较强的关系就不应用这种形式

    例1：
    ```
    //设当前模块为用户库的模块“x/y”

    //正确的导入方式（用别名避免重名）
    import ./z: x_y_z;  //导入“x/y/z”
    import ../z: x_z;   //导入“x/z”
    import ../../z;     //导入用户库的“z”

    //错误的导入方式
    import ././z;       //多个“./”
    import ./../z;      //混用
    import z/../z;      //只支持在描述开头指定相对位置
    import ../../os;    //用户库下没有“os”模块，虽然按照相对路径计算x/y/../../os -> os，但不能跨库去导入标准库的os，也会报错
    import ../../../z;  //向上层数超出了最大层数
    ```

    例2：
    ```
    //设当前模块为“"github.com/a/b"/x/y”

    //正确的导入方式（用别名避免重名）
    import ./z: x_y_z;  //导入“"github.com/a/b"/x/y/z”
    import ../z: x_z;   //导入“"github.com/a/b"/x/z”
    import ../../z;     //导入“"github.com/a/b"/z”

    //错误的导入方式
    import ../../../"github.com/c/d"/x; //向上层数超出了git项目，而且也跨库了，何况也没有`/`中间写git项目的语法
    ```

### **from import方式**

若一次导入的多个模块拥有公有的前缀，为了方便则可以使用`from import`方式，做法就是将上面的“导入模块描述”在某分级的斜杠`/`处拆分，
分别放在from和import的位置

格式：`from <导入模块描述的公共前缀部分> import <导入模块描述后缀部分>[:<别名>][, <导入模块描述后缀部分>[:<别名>]]...;`

编译器会将公共前缀和各后缀分别拼接，再按import方式的流程处理，前后缀拼接后需要符合上述import方式中导入模块描述的规则

例：
```
//设当前模块为用户库的模块“x/y”

from . import z: x_y_z, w;                              //导入“x/y/z”和“x/y/w”
from .. import z: x_z, ../z;                            //导入“x/z”和用户库的“z”
from "github.com/a/b" import x/y: b_x_y, z: b_z;        //导入“"github.com/a/b"/x/y”和“"github.com/a/b"/z”
from "github.com/a/b"/x import y/z: b_x_y_z, z: b_x_z;  //导入“"github.com/a/b"/x/y/z”和“"github.com/a/b"/x/z”
```
