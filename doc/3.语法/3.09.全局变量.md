# **全局变量**

全局变量的相关信息在之前的章节中都提到过，本节详细说明一下

## **语法**

### **定义**

全局变量的定义在代码文件的全局区域（即不在类、接口或函数内部）

语法格式：`[public] [final] 类型 变量名 [= 初始化表达式][, 变量名 [= 初始化表达式]]...[,];`

* `public`修饰表示变量公开，其他模块可以存取

* `final`修饰表示变量初始化后不可再进行赋值（包括通过参数引用的形式，见后）

* 必须明确指定类型

* 可以定义多个变量，每个变量都有同样的类型和修饰

* 各变量可以选择用表达式初始化或不初始化（使用默认的零值）

* 遵循‘3.8.名字查找’一节中的规范

### **使用**

使用当前模块的全局变量，直接用其名字即可（Larva严格规定局部变量不得和上层名字重合，见‘3.8.名字查找’）

被导入的模块的全局变量采用`模块名.全局变量名`来存取

全局变量如被`final`修饰，则不可做赋值操作

例：
```
import x;

final int A = 0x1;
int a = 123;

void f(int b)
{
    int c = b + 1;  //存取局部变量b和c
    a += c * 2;     //存取全局变量a
    x.a -= a;       //假设模块x有一个全局变量“public int a”，用其和本模块的a做计算来更新它
}

void g()
{
    println(A); //正常打印A的值
    A = 456;    //错误，A是final的，不可赋值修改
    ++ A;       //错误，自增自减和增量赋值都算是赋值，不可以进行
}
```

## **初始化**

如‘3.5.程序执行’中的说明，全局变量的初始化会在程序启动后、执行main函数之前进行

如果同一个模块出现多个全局变量，Larva只保证单个文件内部的全局变量是按顺序进行初始化的，如果全局变量在初始化时有互相的依赖关系，
开发者需自行保证其依赖顺序，如果以任何流程使用一个还未初始化的全局变量，那么它的值是对应类型的零值

例：
```
int a = b;  //b此时未初始化，是一个0
int b = a;  //这个代码没有问题，b依赖a

final int c = f();  //由于f返回的是d，间接依赖了未初始化的d，所以c是0
                    //尽管下面的d并不依赖c，Larva也不会自动分析依赖关系将d的初始化先于c进行
final int d = 123;

int e = e + 1;  //根据规则，这种代码是合法的，编译器会先识别e是int给它一个零值，然后执行这个初始化，之后e就是1

public int f()
{
    return d;
}
```

*Note*：全局变量的依赖关系分析比较复杂，即便是Go也没有做到100%检测，而且开发者通过合理的设计也能很容易避开问题，
Larva在风格上并不是很推荐使用全局变量

另外，有的时候可能会用`__init`去初始化全局变量，由于`__init`的调用是全局变量初始化之后的事情，所以开发模块内的相关代码时要注意一下这个顺序

例（节选自`os`模块的文件操作相关代码，批量定义文件操作的一些常量）：
```
!<<

import (
    "os"
)

!>>

public final int
    O_RDONLY,
    O_WRONLY,
    O_RDWR,
    O_APPEND,
    O_CREAT,
    O_EXCL,
    O_SYNC,
    O_TRUNC,
;

void __init()
{
    !<<
    lar_gv_@<<O_RDONLY>>    = int32(os.O_RDONLY)
    lar_gv_@<<O_WRONLY>>    = int32(os.O_WRONLY)
    lar_gv_@<<O_RDWR>>      = int32(os.O_RDWR)
    lar_gv_@<<O_APPEND>>    = int32(os.O_APPEND)
    lar_gv_@<<O_CREAT>>     = int32(os.O_CREATE)
    lar_gv_@<<O_EXCL>>      = int32(os.O_EXCL)
    lar_gv_@<<O_SYNC>>      = int32(os.O_SYNC)
    lar_gv_@<<O_TRUNC>>     = int32(os.O_TRUNC)
    !>>
}
```

由于这些常量的值是用的Go的标准库的`os`包中的对应值，Native代码又不能直接写在表达式中，所以只能放函数里面做

当然写成`public final O_RDONLY = _get_O_RDONLY(), ......`也是可以的，而且保证在`__init`执行之前，也可以让后面的其他全局变量依赖，
不过这样需要定义很多`_get_XXX`小函数，太繁琐了，因为模块之间的初始化顺序是严格按依赖顺序的，所以模块内部在保证代码没问题的情况下，
可以用上面这种简化的写法

*Note*：`final`修饰只是在Larva代码层面起到约束作用，目标代码中的对应的实现还是一个普通的非const变量，所以可以用Native代码修改
