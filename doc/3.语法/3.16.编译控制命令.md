# **编译控制命令**

## **概述**

编译控制命令类似C++中的`#if`宏，可用于控制编译器选择代码块进行编译，在泛型编程中很有用，因为有的时候需要根据某个泛型参数来选择不同的代码行为，
在C++的模板编程中，一般可以用偏特化或SFINAE机制来完成这类需求，Larva选择了编译控制命令这种设计

## **语法**

编译控制命令在词法和语法上都比较特殊，它并不是一个运行时执行的语句，在‘3.2.词法元素’的相关小节中已经说明了其词法规则

编译控制命令有`#error`、`#use`和`#if`，它们只能用于函数或方法的实现中，即语句列表中，每种命令的详细说明见下面几个小节

虽然编译控制命令是基于泛型编程的场景衍生出的语法，一般也只在泛型类的方法和泛型函数中使用，但Larva并没有从语法上限制这一点，
在普通的方法和函数中也是可以使用的，只是没有太大意义罢了

对于`#use`和`#if`，有几点规定：

1. 其对代码块的分割不能跨越正常的代码块，即它们分割出的代码块应是一个完整的整体，这一点是在语法分析一开始就做检查的

    例如：

    ```
    //编译失败，#use对代码块的分割跨越了if块
    void f<T>()
    {
        T t;
    #use
        if (t.f())
        {
    #else
        if (t.g())
        {
    #enduse
            println("hi");
        }
    }

    //正确的做法
    void f<T>()
    {
        T t;
        bool b;
    #use
        b = t.f();
    #else
        b = t.g();
    #enduse
        if (b)
        {
            println("hi");
        }
    }
    ```
    这个检测机制其实是通过括号匹配来做的，即将`#use`和`#if`视为特殊的括号

1. 其每个代码块都当做完整的语句列表来编译，即不支持将一个完整的语句分割开

    例如：
    ```
    //编译失败
    void f<T>()
    {
        T t;
    #use
        if (t.f())
    #else
        if (t.g())
    #enduse
        {
            println("hi");
        }
    }
    ```
    这里的`#use`并没有分割正常的语句代码块，会通过上一条的检查，但是它分割了`if`语句，而`#use`的两个代码块是作为完整语句列表来编译的，
    因此其中的两个`if`都会因为缺少`{`而编译失败，最终会在`#else`的代码块编译报错
    
    在下面的小节可以看到，由于`#use`的使用非常灵活，在某些情景下是可能出现一些编译成功但是和想象中不同的结果，因此使用`#use`时一定要小心

## **#error**

语法：`#error 出错信息`，出错信息是一个字符串字面量

`#error`命令指示编译器立即编译失败，并显示其后的出错信息

显然在正常代码中直接用`#error`是没有太大意义的，所以一般是配合`#use`或`#if`来进行工作

例：
```
void f<T>()
{
#if typein(T, {bool})
    ...
#elif typein(T, {int})
    ...
#else
    #error "类型T需要是bool或int"
#endif
}
```

## **#use**

语法：
```
#use
    代码块
[
#oruse
    代码块
]...
#else
    代码块
#enduse
```

即通过`#use`、`#oruse`、`#else`和`#enduse`指定多个代码块，注意必须有`#else`代码块，`#oruse`则可以有任意多个

编译控制规则：编译器依次尝试编译各代码块，以第一个编译成功的代码块为准，如果所有代码块都编译失败，则选择`#else`的代码块进行编译并报错退出

`#use`代码的“编译失败”是指代码块本身的任何语法错误，这意味着包含了开发者的代码错误和开发者预期在`#use`中可能出现的错误，例如：
```
void f<T>()
{
#use
    T t = 123;
    println("T可以被int字面量赋值")  //注意这里少了个分号
#else
    println("T不可以被int字面量赋值");
#enduse
}
```
写这段代码的人想简单地区分`T`是否可以被int字面量赋值，但是由于他不小心将`#use`的代码块写错了，
语法错误导致编译器在任何`T`下都选择了`#else`代码块

由于`#use`过于灵活，这类问题除了小心地使用`#use`和详细的测试外并无太好的办法，一个好的风格是尽量减少`#use`的各个代码块中的代码量，
例如上面的例子可改为：
```
void f<T>()
{
    bool b = false;
#use
    T t = 123;
    b = true;
#else
#enduse
    println("T%s可以被int字面量赋值".("" if b else "不"));
}
```
当然，这样只能减小出问题的概率，而不能彻底解决问题，所以一般来说可以用`#if`处理大多数泛型代码中的类型识别问题，只有在很特殊的情况下会用到`#use`

## **#if**

`#if`和`#use`类似，都是控制编译器选择代码块进行编译，所不同的是它可以通过条件来选择，而不会像`#use`那样直接依靠尝试编译来选择

语法：
```
#if 条件
    代码块
[
#elif 条件
    代码块
]...
#else
    代码块
#endif
```

编译控制规则：编译器依次判断`#if`和各`#elif`后的条件，选择**第一个成立**的条件所对应的代码块进行编译，如果所有条件都不成立，
则选择`#else`代码块进行编译

`#if`后的条件的语法采用类似函数的语法格式：`功能函数(参数列表)`，功能函数是Larva编译器支持的固定的几种，每个函数对应的参数列表的形式也不同，
这个语法并不是普通的表达式，而是固定语法，不过功能函数的名字并不属于关键字或标识符，而是编译控制命令所特有的，不影响正常代码中使用这些名字

目前支持的功能函数有以下几种，分别进行说明：

* `typein`

    用于判断一个类型是否在指定的类型集合中，有两个参数：
    1. 被判定的类型
    2. 花括号`{}`括起来的，逗号分隔的类型列表

    例：
    ```
    void f<T>()
    {
    #if typein(T, {bool})
        println("T是bool");
    #elif typein(T, {float, double})
        println("T是浮点数类型");
    #else
        #error "无效的类型T"
    #endif
    }
    ```

    *Note*：显然如果类型列表只有一个类型，就等同于判定两个类型是否相同；也支持类型列表为空，这时候条件永远不成立

* `typeimplements`

    用于判断一个类型是否实现了一个指定的接口类型：
    1. 被判定的类型
    2. 指定的接口类型，若不是接口类型则编译报错

    例：
    ```
    void f<T>()
    {
    #if typeimplements(T, Callable)
        println("T实现了Callable");
    #elif typeimplements(T, Comparable<T>)
        println("T的对象实例之间可以用cmp方法进行比较");
    #elif typeimplements(T, Any)
        println("T不是一个需要特别关注的类型");
    #else
        #error "任何类型都实现了Any，所以不可能编译到这里"
    #endif
    }
    ```
    `typeimplements`判定的“实现接口”实际是指“对象能隐式转换为指定接口类型”，所以基础类型也算是“实现”了`Any`接口

* `typeisprimitive`

    用于判断一个类型是否为基础类型，有一个参数，是被判定的类型

    例：
    ```
    void f<T>()
    {
    #if typeisprimitive(T)
        println("T是基础类型%s".(type_name<T>()));
    #else
        println("T不是基础类型");
    #endif
    }
    ```

* `typeisarray`

    用于判断一个类型是否为数组类型，有一个参数，是被判定的类型

    例：
    ```
    void f<T>()
    {
    #if typeisarray(T)
        println("T是数组类型%s".(type_name<T>()));
    #else
        println("T不是数组类型");
    #endif
    }
    ```

* `typeisinterface`

    用于判断一个类型是否为借口类型，有一个参数，是被判定的类型

    例：
    ```
    void f<T>()
    {
    #if typeisinterface(T)
        println("T是接口类型%s".(type_name<T>()));
    #else
        println("T不是接口类型");
    #endif
    }
    ```

    注意这个判断和内建泛型函数`is_interface<T>`的区别，后者是运行时动态判断，而`typeisinterface`是编译期的控制，实际开发中可选择适合具体代码的

目前`#if`的判断仅限单个功能函数，即不支持各函数结果之间的`&&`或`||`的逻辑运算，这类需求一般来说较少，可以用其他一些办法来实现

功能函数属于编译器处理和计算的部分，如果有必要可以通过修改编译器代码来新增功能函数
