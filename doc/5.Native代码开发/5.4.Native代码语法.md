# **Native代码语法**

本节说明Native代码的开发语法

## **词法**

在‘3.2.词法元素’的‘特殊词法’中已经说明了Native代码的词法特性，即以独立行的`!<<`和`!>>`包围的，符合Native代码规范的Go代码

## **语法**

Native代码整体上是Go语言代码中嵌入Native宏的组合，因此Native代码的语法规则主要是以下一些内容：
* 相关编译规则和注意事项
* Native宏的用法

### **出现的位置**

Native代码块可以出现在以下几种位置，在各个位置都可以出现任意多个Native代码块：

* Larva代码的全局位置

    全局位置的Native代码会被输出到目标代码中的对应模块的对应文件中，即前面小节提到的每个`.lar`文件对应一个目标的`.go`文件，
    且总是输出到文件开头，这主要是因为Native代码中可能有Go的`import`，需要放在文件开头，例如：
    ```
    public void main()
    {
        !<<
        println(os.Args)
        !>>
    }

    !<<
    import "os"
    !>>
    ```
    这段代码看上去不是很合逻辑，Native代码中Go的`import`放在了Larva的main函数之后，但由于全局域的Native代码是先输出到目标代码的，
    所以也能正常编译运行，并输出`os.Args`的值，当然，这种代码风格是不好的，因此最好还是将带有Go的`import`的Native代码写在开头，
    当然由于多个Native代码块是顺序输出的，Go的`import`应放在第一个Native代码块的开头

* 类的定义中

    可以在类的定义中插入Native代码块，定义其对应的Go的结构体中的Native字段，例如上一节举过的例子：
    ```
    class A
    {
        !<<
        a string
        !>>
        int b;
        !<<
        c interface{}
        !>>
    }
    ```
    编译出的目标代码中的对应结构体是：
    ```
    type lar_cls_modFA81_3_tmp_1_A struct {
        //native_code start
        a string
        //native_code end
        //native_code start
        c interface{}
        //native_code end
        m_b int32
    }
    ```
    可以看到除了注释外，就是将Native代码原样输出到结构体定义的位置，因此这种位置的Native代码必须只能含有Go语法的结构体字段定义

    对于类中Native代码定义字段和Larva层面的属性定义共存的情况，目前的实现是先按顺序输出Native代码块，再输出Larva的各属性定义，
    但是开发者不能依赖这个顺序，Larva只保证类定义的Native代码块之间的相对顺序和Larva层面的各属性定义的相对顺序和目标代码中的输出顺序一致

* 函数和方法的语句列表中

    函数和方法的语句列表中可嵌入Native代码块，Larva在编译时会将其原样插入到对应的目标代码的对应位置中

    例如：
    ```
    public void main()
    {
        !<<
        println(123)
        !>>
        println("hello");
        !<<
        println("hi")
        !>>
    }
    ```
    这个main函数代码的编译结果为：
    ```
    func lar_func_modFA81_3_tmp_4_main(lar_fiber *lar_go_stru_fiber)  {
        //native_code start
            println(123)
        //native_code end
        lar_func_mod6D07_10___builtins_7_println(lar_fiber, lar_literal_str_modFA81_3_tmp_3719)
        //native_code start
            println("hi")
        //native_code end
        return
    }
    ```
    可以看到是按对应位置输出，并且每个Native代码块首尾都有注释

    在Native代码中，如果用到Larva中的变量、类、接口、函数、属性、方法等语法元素，请根据‘5.3.目标代码规范’中的名字编码规范，
    结合Native宏进行使用，Native宏的用法见下

    注意Native代码对编译器来说是一个完整的token，会保留至语法分析阶段，这意味着它前后的代码都应该是合法的Larva代码，
    当Native代码出现在语句列表中时，可将它视为一个独立的“语句”，例如：
    ```
    public void main()
    {
        println("hello")    //这里少了分号，会编译错误
        !<<
        ;                   //通过Native代码的直接输出补上上一句的分号是行不通的
        println("hi")
        !>>
        ;                   //在这里补分号也是行不通的，Native代码块不可以插入到完整语句的中间
    }
    ```

    Larva并不对Native代码做语法分析，这意味着只要不违反上面这条，开发者有很高的自由度去安排代码，例如：
    ```
    public void main()
    {
        !<<
        for i := 0; i < 3; i ++ {
        !>>
            println("hello");
        !<<
        }
        !>>
    }
    ```
    这是用Native代码设置了Go层面的循环语句的开始和结束，循环体的代码则改用Larva实现，
    而最终编译输出只要能将其“拼凑”成一段合法的Go代码即可成功编译执行，但是这种做法打乱了Larva层面的代码块边界，
    例如上面的例子中，若在循环中定义Larva变量，循环后面就访问不到了，会导致Go层面的编译错误

    总之，Native代码的灵活性的代价就是需要开发者仔细设计代码结构和开发，Larva编译器只保证检查出纯Larva层面的语法问题，
    Native代码导致的错误可能被延迟到Go的编译阶段

### **Native宏**

在开发Native代码的时候，不可避免需要引用到Larva层面的语法元素，在‘5.3.目标代码规范’中已经说明了各种Larva的语法元素的名字的编码规范，
但只靠这个是不能工作的，有几条原因：
* 除局部变量、属性和public方法的编码格式较为简单固定外，其他很多名字的编码规范都需要模块名编码的参与，而模块名编码在开发阶段是不可能知道的
* 很多类型的名字编码非常冗长，导致开发不便
* 泛型编程中，可能需要在Native代码中引用泛型参数

为解决这些问题，Larva设计了Native宏来实现相关功能

Native宏的格式是以开始标记`@<<`开始，结束标记`>>`结束，在二者之间的字符串作为宏的内容，且宏的内容不可跨行写，意即两个标记必须同行

**注意**：编译器对Native宏的处理并不是语法分析，而是简单的文本分析和替换，具体流程是：
1. 找到Native宏的开始标记`@<<`，然后在其所在行找位于其后的结束标记`>>`
1. 将二者中间的字符串作为宏的内容进行分析，决定替换的内容
1. 代码输出阶段，将整个宏文本替换为需要的内容（包括开始和结束标记在内）

编译器认为一个开始标记必然对应一个结束标记，而且其中的内容是**精确**的宏内容，连不必要的空白符都不能有，开发时务必注意

由于开始标记`@<<`不可能出现在正常的Go代码中（至少目前是），因此不会和正常的Go语法冲突，但对于Go中的注释或字符串存在`@<<`的情况，
Larva编译器也是直接做文本分析和替换的，如果一定要使用，请采用变通的办法，常见做法是将标记拆开，例如：
```
public void main()
{
    //这个代码块会编译失败，Go的字符串中的开始标记被作为合法宏来分析了
    !<<
    println("Larva的Native宏的开始标记是‘@<<’")
    !>>

    //改成这样就可以了
    !<<
    println("Larva的Native宏的开始标记是‘@" + "<<’")
    !>>
}
```

Native宏的内容有以下几种指代格式：

* 指代泛型参数

    用于泛型类和泛型函数包含的Native代码中，格式：`{泛型参数}`

    编译器在目标代码中输出泛型实例时，将宏替换为指定的泛型参数实际代表的类型的编码

    例如：
    ```
    class A<T>
    {
        A(long size)
        {
            !<<
            this.s = make([]@<<{T}>>, l_size)
            !>>
        }

        !<<
        s []@<<{T}>>
        !>>
    }
    ```
    这个泛型类的泛型实例在目标代码中会有一个名为`s`的字段，类型为对应的泛型实例的类型`T`的切片，在构造方法中对这个切片进行了初始化

* 指代`模块名.名字`的组合

    格式有三种：
    * `模块名.名字`
    * `:名字`，指代内建模块的名字，等同于`__builtins.名字`的简写
    * `名字`，指代当前模块的名字

    规则：
    * 这个宏会在目标代码中被替换成`模块名编码_名字长度_名字`，即上一节中经常出现的模块名+名字的编码组合

        由于Native宏的处理只是文本替换，因此只需要这样一个宏的格式即可结合上一节中的各种名字编码规范构建各种名字，例如：
        ```
        import util;

        public void main()
        {
            util.HashMap<int, String> m;
            Any a = m;
            !<<
            m, ok := (l_a).(*lar_gcls_inst_@<<util.HashMap>>_2_int32_lar_cls_@<<:String>>)
            if ok && m == l_m {
                println("ok")
            } else {
                panic("fail")
            }
            !>>
        }
        ```
        根据上一节讲的命名编码规则和这一节的宏替换的规则，
        `lar_gcls_inst_@<<util.HashMap>>_2_int32_lar_cls_@<<:String>>`将被替换为`util.HashMap<int, String>`的名字编码，
        例如`lar_gcls_inst_mod05C7_4_util_7_HashMap_2_int32_lar_cls_mod6D07_10___builtins_6_String`

    * 如果指定了模块名，则这里的模块名必须是Native代码块所在的文件中显式导入的模块名或模块别名

        若名字未被导入则会编译错误

        例如：
        ```
        public void main()
        {
            //编译错误，os未显式导入
            !<<
            println(lar_gv_@<<os.O_RDWR>>)
            !>>
        }
        ```

    * 冒号`:`开头和省略当前模块名的写法只是一种简写形式，相当于编译器会自动补充`__builtins.`和`当前模块名.`

        * *Note*：当然了，由于`__builtins`是标准库私有模块，普通代码无法导入；而很少有模块会显式导入自己，所以一般也只能采用简写形式

### **其他说明**

* 由于Native代码的开发形式是在Larva的`.lar`文件中嵌入，等于是两种语言混写，开发的时候建议认真设计代码结构和实现，并多加注释，尽量保证可读性

* 如上所述，函数和方法的实现中的Native代码可以自行设置Go级别的代码块边界，但为了可读性，一般来说不要这样用，除非是一些很底层的不经常维护的代码，
实际上Native代码并不是一个开发常态，一般都用于封装一些基础库

* 由于Go语言语句末尾可以不用分号`;`，虽然写了也不算错，但是不建议这样，Larva编译器会额外检查Native代码的每一行，如果以分号结尾，则会报出警告

* Native代码通过名字编码只能使用Larva层面的代码定义过的类型

    例如：
    ```
    public void main()
    {
        !<<
        var a *lar_arr_int32_5
        !>>
    }
    ```
    这里使用到的名字编码是类型`int[][][][][]`的，如果这个程序涉及的模块中有定义过这个数组，则这段代码会编译成功，否则失败，
    因此如果要在Native代码中使用Larva类型，最好的办法是在所在模块内部先保证其存在，例如可以采用定义一个无用的变量、函数等方式，
    只要在Larva代码层面出现一次相关类型即可
