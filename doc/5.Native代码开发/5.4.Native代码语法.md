# **Native代码语法**

本节说明Native代码的开发语法

## **词法**

在‘3.2.词法元素’的‘特殊词法’中已经说明了Native代码的词法特性，即以独立行的`!<<`和`!>>`包围的，符合Native代码规范的Go代码

## **语法**

Native代码整体上是Go语言代码中嵌入Native宏的组合，因此Native代码的语法规则主要是以下一些内容：
* 相关编译规则和注意事项
* Native宏的用法

### **出现的位置**

Native代码块可以出现在以下几种位置，在各个位置都可以出现任意多个Native代码块：

* Larva代码的全局位置

    全局位置的Native代码会被输出到目标代码中的对应模块的对应文件中，即前面小节提到的每个`.lar`文件对应一个目标的`.go`文件，
    且总是输出到文件开头，这主要是因为Native代码中可能有Go的`import`，需要放在文件开头，例如：
    ```
    public void main()
    {
        !<<
        println(os.Args)
        !>>
    }

    !<<
    import "os"
    !>>
    ```
    这段代码看上去不是很合逻辑，Native代码中Go的`import`放在了Larva的main函数之后，但由于全局域的Native代码是先输出到目标代码的，
    所以也能正常编译运行，并输出`os.Args`的值，当然，这种代码风格是不好的，因此最好还是将带有Go的`import`的Native代码写在开头，
    当然由于多个Native代码块是顺序输出的，Go的`import`应放在第一个Native代码块的开头

* 类的定义中

    可以在类的定义中插入Native代码块，定义其对应的Go的结构体中的Native字段，例如上一节举过的例子：
    ```
    class A
    {
        !<<
        a string
        !>>
        int b;
        !<<
        c interface{}
        !>>
    }
    ```
    编译出的目标代码中的对应结构体是：
    ```
    type lar_cls_modFA81_3_tmp_1_A struct {
        //native_code start
        a string
        //native_code end
        //native_code start
        c interface{}
        //native_code end
        m_b int32
    }
    ```
    可以看到除了注释外，就是将Native代码原样输出到结构体定义的位置，因此这种位置的Native代码必须只能含有Go语法的结构体字段定义

    对于类中Native代码定义字段和Larva层面的属性定义共存的情况，目前是先按顺序输出Native代码块，再输出Larva的各属性定义，开发者不能依赖这个顺序

* 函数和方法的语句列表中

    函数和方法的语句列表中可嵌入Native代码块，Larva在编译时会将其原样插入到对应的目标代码的对应位置中

    例如：
    ```
    public void main()
    {
        !<<
        println(123)
        !>>
        println("hello");
        !<<
        println("hi")
        !>>
    }
    ```
    这个main函数代码的编译结果为：
    ```
    func lar_func_modFA81_3_tmp_4_main(lar_fiber *lar_go_stru_fiber)  {
        //native_code start
            println(123)
        //native_code end
        lar_func_mod6D07_10___builtins_7_println(lar_fiber, lar_literal_str_modFA81_3_tmp_3719)
        //native_code start
            println("hi")
        //native_code end
        return
    }
    ```
    可以看到是按对应位置输出，并且每个Native代码块首尾都有注释

    在Native代码中，如果用到Larva中的变量、类、接口、函数、属性、方法等语法元素，请根据‘5.3.目标代码规范’中的名字编码规范，
    结合Native宏进行使用，Native宏的用法见下

    注意Native代码对编译器来说是一个完整的token，会保留至语法分析阶段，这意味着它之外的代码都应该是合法的Larva代码，例如：
    ```
    public void main()
    {
        println("hello")    //这里少了分号，会编译错误
        !<<
        ;                   //通过Native代码的直接输出补上上一句的分号是行不通的
        println("hi")
        !>>
    }
    ```

    Larva并不对Native代码做语法分析，这意味着只要不违反上面这条，开发者有很高的自由度去安排代码，例如：
    ```
    public void main()
    {
        !<<
        for i := 0; i < 3; i ++ {
        !>>
            println("hello");
        !<<
        }
        !>>
    }
    ```
    这是用Native代码设置了Go层面的循环语句的开始和结束，循环体的代码则改用Larva实现，
    而最终编译输出只要能将其“拼凑”成一段合法的Go代码即可成功编译执行，但是这种做法打乱了Larva层面的代码块边界，
    例如上面的例子中，若在循环中定义Larva变量，循环后面就访问不到了，会导致Go层面的编译错误

    总之，Native代码的灵活性的代价就是需要开发者仔细设计代码结构和开发，Larva编译器只保证检查出纯Larva层面的语法问题，
    Native代码导致的错误可能被延迟到Go的编译阶段

### **Native宏**

在开发Native代码的时候，不可避免需要引用到Larva层面的语法元素，在‘5.3.目标代码规范’中已经说明了各种Larva的语法元素的名字的编码规范，
但只靠这个是不能工作的，有几条原因：
* 除局部变量、属性和public方法的编码格式较为简单固定外，其他很多名字的编码规范都需要模块名编码的参与，而模块名编码在开发阶段是不可能知道的
* 很多类型的名字编码非常冗长，导致开发不便
* 泛型编程中，可能需要在Native代码中引用泛型参数

为解决这些问题，Larva设计了Native宏来实现相关功能

Native宏的格式是以开始标记`@<<`开始，结束标记`>>`结束，在二者之间的字符串作为宏的内容，且宏的内容不可跨行写，意即两个标记必须同行

**注意**：编译器对Native宏的处理并不是语法分析，而是简单的文本分析和替换，具体流程是：
1. 找到Native宏的开始标记`@<<`，然后在其所在行找位于其后的结束标记`>>`
1. 将二者中间的字符串作为宏的内容进行分析，决定替换的内容
1. 代码输出阶段，将整个宏文本替换为需要的内容（包括开始和结束标记在内）

编译器认为一个开始标记必然对应一个结束标记，而且其中的内容是**精确**的宏内容，连不必要的空白符都不能有，开发时务必注意

由于开始标记`@<<`不可能出现在正常的Go代码中（至少目前是），因此不会和正常的Go语法冲突，但对于Go中的注释或字符串存在`@<<`的情况，
Larva编译器也是直接做文本分析和替换的，如果一定要使用，请采用变通的办法，常见做法是将标记拆开，例如：
```
public void main()
{
    //这个代码块会编译失败，Go的字符串中的开始标记被作为合法宏来分析了
    !<<
    println("Larva的Native宏的开始标记是‘@<<’")
    !>>

    //改成这样就可以了
    !<<
    println("Larva的Native宏的开始标记是‘@" + "<<’")
    !>>
}
```

Native宏的内容有以下几种指代格式：

* 指代泛型参数

    用于泛型类和泛型函数包含的Native代码中，格式：`{泛型参数}`

    编译器在目标代码中输出泛型实例时，将宏替换为指定的泛型参数实际代表的类型的编码

    例如：
    ```
    class A<T>
    {
        A(long size)
        {
            !<<
            this.s = make([]@<<{T}>>, l_size)
            !>>
        }

        !<<
        s []@<<{T}>>
        !>>
    }
    ```
    这个泛型类的泛型实例在目标代码中会有一个名为`s`的字段，类型为对应的泛型实例的类型`T`的切片，在构造函数对这个切片进行了初始化

* 指代`模块名.名字`的组合

    todo

### **其他说明**

* 由于Native代码的开发形式是在Larva的`.lar`文件中嵌入，等于是两种语言混写，开发的时候需要注意代码设计和实现，尽量保证可读性

* 如上所述，函数和方法的实现中的Native代码可以自行设置Go级别的代码块边界，但为了可读性，一般来说不要这样用，除非是一些很底层的不经常维护的代码，
实际上Native代码并不是一个开发常态，一般都用于封装一些基础库

* 由于Go语言语句末尾可以不用分号`;`，虽然写了也不算错，但是不建议这样，Larva编译器会额外检查Native代码的每一行，如果以分号结尾，则会报出警告
