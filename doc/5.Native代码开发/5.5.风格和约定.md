# **风格和约定**

本节用于说明Larva比较推荐的Native代码的开发风格和一些约定，这里说的并不是强制性的语法规定，而是为了避免出现问题的一些建议性的约定

## **全局域的Native代码**

全局域的Native代码包含的Go代码层面的语法元素有：
* 导入package
* 定义全局变量
* 定义函数
* 定义结构体、接口等

### **命名风格**

* 自定义的Native全局元素都以`lar_`前缀
    * 自定义的结构体、函数、接口等可以以`lar_go_`前缀开头，意即属于Larva的Native代码中的Go样式的元素，例如`lar_go_stru`、`lar_go_func`等
* 由于Larva语法元素都带有对应前缀，因此在Native代码中可以很容易和Go层面的各种名字区分开，但还是要尽量规避可能的冲突，建议：
    * 请不要使用Go的`import . "package"`的语法导入一个package的所有对外名字
        * *Note*：其实就算这样导入了，也不会和Larva自身的名字冲突，因为导入的都是Go的对外名字，即大写字母开头的，而Larva的名字编码都是小写开头，
        不过导入一个package所有名字这个做法本身会引起可读性和理解上的问题，在正常的Go开发中我也是不推荐的
    * 模块名本身一般也不会以`lar_`开头，而且Go也支持设置导入模块的别名，必要时用这个机制即可
* 由于Larva的目标代码是将所有模块整合成一个Go的package，若Larva中多个模块都含有Native全局元素时，为避免命名冲突，
建议开发者使用宏来组合名字编码，例如`tmp`模块若需要一个Native函数，可命名为`lar_go_func_@<<xxx>>`，
这样和其他模块中定义的`lar_go_func_@<<xxx>>`就不会有冲突了
* 标准库中有一些特有的语法元素名字，例如`lar_util_`开头的，用于运行时通用功能的，以及`lar_reflect_`开头的用于反射的，
它们的命名法有的是历史原因，有的是为了特别区分开，建议开发者如果开发自己的Native全局元素，统一使用`lar_go_`开头

### **标准库的Native支持**

一些标准库模块的代码中提供了Native函数、结构体、接口等，可供开发者开发Native代码时使用，常见的例如Go的`string`和Larva的`String`的转换函数等，
在‘4.标准库’的各模块文档中会提供说明，若在标准库中实现了但是没有通过文档介绍的，则表示是内部使用，不推荐开发者直接使用

## **Native字段定义**

类的定义中含有的Native代码块是用来定义Native字段的，需要采用的Go的字段定义语法，建议风格：
* 属性命名风格需要尽量避免名字冲突
    * 不要使用Larva的属性的目标代码命名样式（`m_`开头）
    * 不要采用局部变量（`l_`开头）和全局域Native元素（`lar_`开头）的样式
    * 只要和其他约定不冲突，命名规范本身可以只用单词缩写，但最好不要和同一个类的Larva级别的属性同名
        * 例如如果一个类有一个Larva属性`a`，虽然在目标代码中会被编码为`m_a`，再定义一个Native字段`a`也没有问题，但会对可读性有影响
* 字段的类型一般应是Go的类型而非Larva的类型，因为如果使用Larva类型的属性的话，一般可以在Larva代码层面定义
* 由于一个Larva程序的所有模块的目标代码都在一个Go的package中，因此用普通的私有名字即可，特殊需求（比如需要用Go的反射）可使用Go的公有名字

## **语句列表的Native代码**

语句列表中的Native代码相当于内嵌Go的语句，建议风格：
* 在整个程序框架上，带有Native的函数或方法（类）应在一个相对底层的位置，即应该用Larva语法元素对其实现进行封装，由上层调用，
在应用开发层应尽量使用纯Larva开发
* 在代码结构安排上尽量采用Larva代码实现框架，Native代码实现具体细节，在此前提下尽量使用Larva代码进行开发
    * 除非有很大的性能提升，或者大量Native代码块和Larva代码交错影响可读性
* 和Native属性的命名风格类似，Native局部变量名不应以`l_`前缀开头，不要和当前函数或方法的Larva代码级别的局部变量重名，
也不要采用`m_`或`lar_`开头的样式
