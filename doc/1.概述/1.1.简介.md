# **简介**

Larva是我做的一门程序设计语言，和大多数编译为机器码或在虚拟机解释执行的语言不同，它是以Golang直接作为后端，
也就是说Larva代码会被编译为Golang代码，进而调用Golang的编译器进行第二轮编译并生成目标程序

现在这个项目是2017年开始搞的，之前还有一个版本，是采用java作为后端，且从语法到实现和现在完全不同，那个项目已经移到了我的个人项目，
改名为larva_4j，可访问
<https://github.com/maopao-691515082/larva-lang_4j>

## ***Note***

**用一门现成的语言作为后端，对于语言设计、编译器开发等工作有很大的便利：**

* 编译器只需要注重前端开发和代码生成，不需要过多考虑代码优化
* 生成的目标代码本身是高级语言，方便调试问题
* 很多runtime特性，例如gc、traceback等，都可直接利用后端语言的成熟实现，而不需要额外造轮子，程序运行的稳定性有保障
* 语法设计方面可以借鉴后端语言，并实现简单编译转化同时保障目标代码的可读性；也可实现与其差别比较大的语法，然后通过较复杂的编译过程进行转化

**既然目标代码也是高级语言，为何不直接使用它而是另外设计？**

* 现有的高级语言多多少少都有一些让我不爽的地方，很多语言可能采用库的方式来解决一些开发上的便利性问题（如一些C++协程库），
或对于运行时的问题采用修改虚拟机、运行库进行改进，这样做有一个很大的好处就是可以直接用上此语言现有的积累，但我认为这样做可能包袱太重，
重头设计相对比较好

    * *Note*：这个问题也可类比“理论上我们可以直接用汇编甚至机器语言开发，为何还需高级语言？”，后者的答案就很明显了，因为汇编开发成本太高，
    而高级语言之间的转换所减少的成本（或者说提升的便利性）相对于目标代码本身的便利性可能不是那么明显，就Larva来说，
    如果你认为Golang已经足够方便了，那么Larva的价值就不是那么高，这个因人而异，也和具体的需求场景有关

* 使用现有高级语言作为后端，意味着通过简单的native封装即可将后端语言的所有库利用起来

* 具体到Golang这个后端，主要在几个方面进行了借鉴和改进：
    * 语法层面更加贴近C++和Java，也吸收了Golang中比较好的一些设计

    * 对Golang中个人认为较为晦涩或不方便的地方做了修改，例如：
        * 类型系统采用类似Java的设计，区分基础类型和对象类型，前者按值传递/赋值，后者则按句柄引用进行传递/赋值和操作
        * 去掉了指针语法和多值返回，增加了类似C#的ref参数传递语法
        * 和Golang一样不支持直接继承，但也不直接用匿名包含的设计，而是改成了usemethod机制
        * 其他的一些小修改

    * 增加了泛型的支持
        * 泛型实现采用C++模板替换的方式，而非用多态实现，用代码膨胀换取基础类型容器等场景下的较好表现
        * 设计实现了#use和#if等编译控制命令，可实现类似C++模板的特化和SFINEA机制
        * 泛型函数支持参数类型推导，且推导过程实现了接口适配分析

    * 错误处理方面，将Golang的错误码返回机制改为异常处理，实现了的异常捕获和traceback跟踪信息获取

    * 简化了模块管理

    * 隐式统一的context

    * 更简便的反射接口
